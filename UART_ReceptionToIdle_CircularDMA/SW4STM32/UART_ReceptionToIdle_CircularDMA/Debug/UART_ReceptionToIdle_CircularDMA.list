
UART_ReceptionToIdle_CircularDMA.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001c60  080001ac  080001ac  000101ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000020  08001e0c  08001e0c  00011e0c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08001e2c  08001e2c  00011e2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08001e34  08001e34  00011e34  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08001e38  08001e38  00011e38  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000054  20000000  08001e3c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020054  2**0
                  CONTENTS
  8 .bss          00000110  20000054  20000054  00020054  2**2
                  ALLOC
  9 ._user_heap_stack 00000604  20000164  20000164  00020054  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00020054  2**0
                  CONTENTS, READONLY
 11 .debug_line   0000c1c5  00000000  00000000  00020084  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_info   0000bbc5  00000000  00000000  0002c249  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00001ef7  00000000  00000000  00037e0e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000688  00000000  00000000  00039d08  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    000ce6c9  00000000  00000000  0003a390  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 000008c0  00000000  00000000  00108a60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loc    00006439  00000000  00000000  00109320  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  000213e0  00000000  00000000  0010f759  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  00130b39  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000112c  00000000  00000000  00130b8c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001ac <__do_global_dtors_aux>:
 80001ac:	b510      	push	{r4, lr}
 80001ae:	4c05      	ldr	r4, [pc, #20]	; (80001c4 <__do_global_dtors_aux+0x18>)
 80001b0:	7823      	ldrb	r3, [r4, #0]
 80001b2:	b933      	cbnz	r3, 80001c2 <__do_global_dtors_aux+0x16>
 80001b4:	4b04      	ldr	r3, [pc, #16]	; (80001c8 <__do_global_dtors_aux+0x1c>)
 80001b6:	b113      	cbz	r3, 80001be <__do_global_dtors_aux+0x12>
 80001b8:	4804      	ldr	r0, [pc, #16]	; (80001cc <__do_global_dtors_aux+0x20>)
 80001ba:	f3af 8000 	nop.w
 80001be:	2301      	movs	r3, #1
 80001c0:	7023      	strb	r3, [r4, #0]
 80001c2:	bd10      	pop	{r4, pc}
 80001c4:	20000054 	.word	0x20000054
 80001c8:	00000000 	.word	0x00000000
 80001cc:	08001df4 	.word	0x08001df4

080001d0 <frame_dummy>:
 80001d0:	b508      	push	{r3, lr}
 80001d2:	4b03      	ldr	r3, [pc, #12]	; (80001e0 <frame_dummy+0x10>)
 80001d4:	b11b      	cbz	r3, 80001de <frame_dummy+0xe>
 80001d6:	4903      	ldr	r1, [pc, #12]	; (80001e4 <frame_dummy+0x14>)
 80001d8:	4803      	ldr	r0, [pc, #12]	; (80001e8 <frame_dummy+0x18>)
 80001da:	f3af 8000 	nop.w
 80001de:	bd08      	pop	{r3, pc}
 80001e0:	00000000 	.word	0x00000000
 80001e4:	20000058 	.word	0x20000058
 80001e8:	08001df4 	.word	0x08001df4

080001ec <__aeabi_uldivmod>:
 80001ec:	b953      	cbnz	r3, 8000204 <__aeabi_uldivmod+0x18>
 80001ee:	b94a      	cbnz	r2, 8000204 <__aeabi_uldivmod+0x18>
 80001f0:	2900      	cmp	r1, #0
 80001f2:	bf08      	it	eq
 80001f4:	2800      	cmpeq	r0, #0
 80001f6:	bf1c      	itt	ne
 80001f8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80001fc:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000200:	f000 b974 	b.w	80004ec <__aeabi_idiv0>
 8000204:	f1ad 0c08 	sub.w	ip, sp, #8
 8000208:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800020c:	f000 f806 	bl	800021c <__udivmoddi4>
 8000210:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000214:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000218:	b004      	add	sp, #16
 800021a:	4770      	bx	lr

0800021c <__udivmoddi4>:
 800021c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000220:	9d08      	ldr	r5, [sp, #32]
 8000222:	4604      	mov	r4, r0
 8000224:	468e      	mov	lr, r1
 8000226:	2b00      	cmp	r3, #0
 8000228:	d14d      	bne.n	80002c6 <__udivmoddi4+0xaa>
 800022a:	428a      	cmp	r2, r1
 800022c:	4694      	mov	ip, r2
 800022e:	d969      	bls.n	8000304 <__udivmoddi4+0xe8>
 8000230:	fab2 f282 	clz	r2, r2
 8000234:	b152      	cbz	r2, 800024c <__udivmoddi4+0x30>
 8000236:	fa01 f302 	lsl.w	r3, r1, r2
 800023a:	f1c2 0120 	rsb	r1, r2, #32
 800023e:	fa20 f101 	lsr.w	r1, r0, r1
 8000242:	fa0c fc02 	lsl.w	ip, ip, r2
 8000246:	ea41 0e03 	orr.w	lr, r1, r3
 800024a:	4094      	lsls	r4, r2
 800024c:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000250:	0c21      	lsrs	r1, r4, #16
 8000252:	fbbe f6f8 	udiv	r6, lr, r8
 8000256:	fa1f f78c 	uxth.w	r7, ip
 800025a:	fb08 e316 	mls	r3, r8, r6, lr
 800025e:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8000262:	fb06 f107 	mul.w	r1, r6, r7
 8000266:	4299      	cmp	r1, r3
 8000268:	d90a      	bls.n	8000280 <__udivmoddi4+0x64>
 800026a:	eb1c 0303 	adds.w	r3, ip, r3
 800026e:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
 8000272:	f080 811f 	bcs.w	80004b4 <__udivmoddi4+0x298>
 8000276:	4299      	cmp	r1, r3
 8000278:	f240 811c 	bls.w	80004b4 <__udivmoddi4+0x298>
 800027c:	3e02      	subs	r6, #2
 800027e:	4463      	add	r3, ip
 8000280:	1a5b      	subs	r3, r3, r1
 8000282:	b2a4      	uxth	r4, r4
 8000284:	fbb3 f0f8 	udiv	r0, r3, r8
 8000288:	fb08 3310 	mls	r3, r8, r0, r3
 800028c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000290:	fb00 f707 	mul.w	r7, r0, r7
 8000294:	42a7      	cmp	r7, r4
 8000296:	d90a      	bls.n	80002ae <__udivmoddi4+0x92>
 8000298:	eb1c 0404 	adds.w	r4, ip, r4
 800029c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80002a0:	f080 810a 	bcs.w	80004b8 <__udivmoddi4+0x29c>
 80002a4:	42a7      	cmp	r7, r4
 80002a6:	f240 8107 	bls.w	80004b8 <__udivmoddi4+0x29c>
 80002aa:	4464      	add	r4, ip
 80002ac:	3802      	subs	r0, #2
 80002ae:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80002b2:	1be4      	subs	r4, r4, r7
 80002b4:	2600      	movs	r6, #0
 80002b6:	b11d      	cbz	r5, 80002c0 <__udivmoddi4+0xa4>
 80002b8:	40d4      	lsrs	r4, r2
 80002ba:	2300      	movs	r3, #0
 80002bc:	e9c5 4300 	strd	r4, r3, [r5]
 80002c0:	4631      	mov	r1, r6
 80002c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002c6:	428b      	cmp	r3, r1
 80002c8:	d909      	bls.n	80002de <__udivmoddi4+0xc2>
 80002ca:	2d00      	cmp	r5, #0
 80002cc:	f000 80ef 	beq.w	80004ae <__udivmoddi4+0x292>
 80002d0:	2600      	movs	r6, #0
 80002d2:	e9c5 0100 	strd	r0, r1, [r5]
 80002d6:	4630      	mov	r0, r6
 80002d8:	4631      	mov	r1, r6
 80002da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002de:	fab3 f683 	clz	r6, r3
 80002e2:	2e00      	cmp	r6, #0
 80002e4:	d14a      	bne.n	800037c <__udivmoddi4+0x160>
 80002e6:	428b      	cmp	r3, r1
 80002e8:	d302      	bcc.n	80002f0 <__udivmoddi4+0xd4>
 80002ea:	4282      	cmp	r2, r0
 80002ec:	f200 80f9 	bhi.w	80004e2 <__udivmoddi4+0x2c6>
 80002f0:	1a84      	subs	r4, r0, r2
 80002f2:	eb61 0303 	sbc.w	r3, r1, r3
 80002f6:	2001      	movs	r0, #1
 80002f8:	469e      	mov	lr, r3
 80002fa:	2d00      	cmp	r5, #0
 80002fc:	d0e0      	beq.n	80002c0 <__udivmoddi4+0xa4>
 80002fe:	e9c5 4e00 	strd	r4, lr, [r5]
 8000302:	e7dd      	b.n	80002c0 <__udivmoddi4+0xa4>
 8000304:	b902      	cbnz	r2, 8000308 <__udivmoddi4+0xec>
 8000306:	deff      	udf	#255	; 0xff
 8000308:	fab2 f282 	clz	r2, r2
 800030c:	2a00      	cmp	r2, #0
 800030e:	f040 8092 	bne.w	8000436 <__udivmoddi4+0x21a>
 8000312:	eba1 010c 	sub.w	r1, r1, ip
 8000316:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800031a:	fa1f fe8c 	uxth.w	lr, ip
 800031e:	2601      	movs	r6, #1
 8000320:	0c20      	lsrs	r0, r4, #16
 8000322:	fbb1 f3f7 	udiv	r3, r1, r7
 8000326:	fb07 1113 	mls	r1, r7, r3, r1
 800032a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800032e:	fb0e f003 	mul.w	r0, lr, r3
 8000332:	4288      	cmp	r0, r1
 8000334:	d908      	bls.n	8000348 <__udivmoddi4+0x12c>
 8000336:	eb1c 0101 	adds.w	r1, ip, r1
 800033a:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800033e:	d202      	bcs.n	8000346 <__udivmoddi4+0x12a>
 8000340:	4288      	cmp	r0, r1
 8000342:	f200 80cb 	bhi.w	80004dc <__udivmoddi4+0x2c0>
 8000346:	4643      	mov	r3, r8
 8000348:	1a09      	subs	r1, r1, r0
 800034a:	b2a4      	uxth	r4, r4
 800034c:	fbb1 f0f7 	udiv	r0, r1, r7
 8000350:	fb07 1110 	mls	r1, r7, r0, r1
 8000354:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8000358:	fb0e fe00 	mul.w	lr, lr, r0
 800035c:	45a6      	cmp	lr, r4
 800035e:	d908      	bls.n	8000372 <__udivmoddi4+0x156>
 8000360:	eb1c 0404 	adds.w	r4, ip, r4
 8000364:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
 8000368:	d202      	bcs.n	8000370 <__udivmoddi4+0x154>
 800036a:	45a6      	cmp	lr, r4
 800036c:	f200 80bb 	bhi.w	80004e6 <__udivmoddi4+0x2ca>
 8000370:	4608      	mov	r0, r1
 8000372:	eba4 040e 	sub.w	r4, r4, lr
 8000376:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800037a:	e79c      	b.n	80002b6 <__udivmoddi4+0x9a>
 800037c:	f1c6 0720 	rsb	r7, r6, #32
 8000380:	40b3      	lsls	r3, r6
 8000382:	fa22 fc07 	lsr.w	ip, r2, r7
 8000386:	ea4c 0c03 	orr.w	ip, ip, r3
 800038a:	fa20 f407 	lsr.w	r4, r0, r7
 800038e:	fa01 f306 	lsl.w	r3, r1, r6
 8000392:	431c      	orrs	r4, r3
 8000394:	40f9      	lsrs	r1, r7
 8000396:	ea4f 491c 	mov.w	r9, ip, lsr #16
 800039a:	fa00 f306 	lsl.w	r3, r0, r6
 800039e:	fbb1 f8f9 	udiv	r8, r1, r9
 80003a2:	0c20      	lsrs	r0, r4, #16
 80003a4:	fa1f fe8c 	uxth.w	lr, ip
 80003a8:	fb09 1118 	mls	r1, r9, r8, r1
 80003ac:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80003b0:	fb08 f00e 	mul.w	r0, r8, lr
 80003b4:	4288      	cmp	r0, r1
 80003b6:	fa02 f206 	lsl.w	r2, r2, r6
 80003ba:	d90b      	bls.n	80003d4 <__udivmoddi4+0x1b8>
 80003bc:	eb1c 0101 	adds.w	r1, ip, r1
 80003c0:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
 80003c4:	f080 8088 	bcs.w	80004d8 <__udivmoddi4+0x2bc>
 80003c8:	4288      	cmp	r0, r1
 80003ca:	f240 8085 	bls.w	80004d8 <__udivmoddi4+0x2bc>
 80003ce:	f1a8 0802 	sub.w	r8, r8, #2
 80003d2:	4461      	add	r1, ip
 80003d4:	1a09      	subs	r1, r1, r0
 80003d6:	b2a4      	uxth	r4, r4
 80003d8:	fbb1 f0f9 	udiv	r0, r1, r9
 80003dc:	fb09 1110 	mls	r1, r9, r0, r1
 80003e0:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 80003e4:	fb00 fe0e 	mul.w	lr, r0, lr
 80003e8:	458e      	cmp	lr, r1
 80003ea:	d908      	bls.n	80003fe <__udivmoddi4+0x1e2>
 80003ec:	eb1c 0101 	adds.w	r1, ip, r1
 80003f0:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
 80003f4:	d26c      	bcs.n	80004d0 <__udivmoddi4+0x2b4>
 80003f6:	458e      	cmp	lr, r1
 80003f8:	d96a      	bls.n	80004d0 <__udivmoddi4+0x2b4>
 80003fa:	3802      	subs	r0, #2
 80003fc:	4461      	add	r1, ip
 80003fe:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000402:	fba0 9402 	umull	r9, r4, r0, r2
 8000406:	eba1 010e 	sub.w	r1, r1, lr
 800040a:	42a1      	cmp	r1, r4
 800040c:	46c8      	mov	r8, r9
 800040e:	46a6      	mov	lr, r4
 8000410:	d356      	bcc.n	80004c0 <__udivmoddi4+0x2a4>
 8000412:	d053      	beq.n	80004bc <__udivmoddi4+0x2a0>
 8000414:	b15d      	cbz	r5, 800042e <__udivmoddi4+0x212>
 8000416:	ebb3 0208 	subs.w	r2, r3, r8
 800041a:	eb61 010e 	sbc.w	r1, r1, lr
 800041e:	fa01 f707 	lsl.w	r7, r1, r7
 8000422:	fa22 f306 	lsr.w	r3, r2, r6
 8000426:	40f1      	lsrs	r1, r6
 8000428:	431f      	orrs	r7, r3
 800042a:	e9c5 7100 	strd	r7, r1, [r5]
 800042e:	2600      	movs	r6, #0
 8000430:	4631      	mov	r1, r6
 8000432:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000436:	f1c2 0320 	rsb	r3, r2, #32
 800043a:	40d8      	lsrs	r0, r3
 800043c:	fa0c fc02 	lsl.w	ip, ip, r2
 8000440:	fa21 f303 	lsr.w	r3, r1, r3
 8000444:	4091      	lsls	r1, r2
 8000446:	4301      	orrs	r1, r0
 8000448:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800044c:	fa1f fe8c 	uxth.w	lr, ip
 8000450:	fbb3 f0f7 	udiv	r0, r3, r7
 8000454:	fb07 3610 	mls	r6, r7, r0, r3
 8000458:	0c0b      	lsrs	r3, r1, #16
 800045a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 800045e:	fb00 f60e 	mul.w	r6, r0, lr
 8000462:	429e      	cmp	r6, r3
 8000464:	fa04 f402 	lsl.w	r4, r4, r2
 8000468:	d908      	bls.n	800047c <__udivmoddi4+0x260>
 800046a:	eb1c 0303 	adds.w	r3, ip, r3
 800046e:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 8000472:	d22f      	bcs.n	80004d4 <__udivmoddi4+0x2b8>
 8000474:	429e      	cmp	r6, r3
 8000476:	d92d      	bls.n	80004d4 <__udivmoddi4+0x2b8>
 8000478:	3802      	subs	r0, #2
 800047a:	4463      	add	r3, ip
 800047c:	1b9b      	subs	r3, r3, r6
 800047e:	b289      	uxth	r1, r1
 8000480:	fbb3 f6f7 	udiv	r6, r3, r7
 8000484:	fb07 3316 	mls	r3, r7, r6, r3
 8000488:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800048c:	fb06 f30e 	mul.w	r3, r6, lr
 8000490:	428b      	cmp	r3, r1
 8000492:	d908      	bls.n	80004a6 <__udivmoddi4+0x28a>
 8000494:	eb1c 0101 	adds.w	r1, ip, r1
 8000498:	f106 38ff 	add.w	r8, r6, #4294967295	; 0xffffffff
 800049c:	d216      	bcs.n	80004cc <__udivmoddi4+0x2b0>
 800049e:	428b      	cmp	r3, r1
 80004a0:	d914      	bls.n	80004cc <__udivmoddi4+0x2b0>
 80004a2:	3e02      	subs	r6, #2
 80004a4:	4461      	add	r1, ip
 80004a6:	1ac9      	subs	r1, r1, r3
 80004a8:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 80004ac:	e738      	b.n	8000320 <__udivmoddi4+0x104>
 80004ae:	462e      	mov	r6, r5
 80004b0:	4628      	mov	r0, r5
 80004b2:	e705      	b.n	80002c0 <__udivmoddi4+0xa4>
 80004b4:	4606      	mov	r6, r0
 80004b6:	e6e3      	b.n	8000280 <__udivmoddi4+0x64>
 80004b8:	4618      	mov	r0, r3
 80004ba:	e6f8      	b.n	80002ae <__udivmoddi4+0x92>
 80004bc:	454b      	cmp	r3, r9
 80004be:	d2a9      	bcs.n	8000414 <__udivmoddi4+0x1f8>
 80004c0:	ebb9 0802 	subs.w	r8, r9, r2
 80004c4:	eb64 0e0c 	sbc.w	lr, r4, ip
 80004c8:	3801      	subs	r0, #1
 80004ca:	e7a3      	b.n	8000414 <__udivmoddi4+0x1f8>
 80004cc:	4646      	mov	r6, r8
 80004ce:	e7ea      	b.n	80004a6 <__udivmoddi4+0x28a>
 80004d0:	4620      	mov	r0, r4
 80004d2:	e794      	b.n	80003fe <__udivmoddi4+0x1e2>
 80004d4:	4640      	mov	r0, r8
 80004d6:	e7d1      	b.n	800047c <__udivmoddi4+0x260>
 80004d8:	46d0      	mov	r8, sl
 80004da:	e77b      	b.n	80003d4 <__udivmoddi4+0x1b8>
 80004dc:	3b02      	subs	r3, #2
 80004de:	4461      	add	r1, ip
 80004e0:	e732      	b.n	8000348 <__udivmoddi4+0x12c>
 80004e2:	4630      	mov	r0, r6
 80004e4:	e709      	b.n	80002fa <__udivmoddi4+0xde>
 80004e6:	4464      	add	r4, ip
 80004e8:	3802      	subs	r0, #2
 80004ea:	e742      	b.n	8000372 <__udivmoddi4+0x156>

080004ec <__aeabi_idiv0>:
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop

080004f0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  ldr   sp, =_estack       /* set stack pointer */
 80004f0:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000528 <LoopFillZerobss+0x12>
 
/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 80004f4:	480d      	ldr	r0, [pc, #52]	; (800052c <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 80004f6:	490e      	ldr	r1, [pc, #56]	; (8000530 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 80004f8:	4a0e      	ldr	r2, [pc, #56]	; (8000534 <LoopFillZerobss+0x1e>)
  movs r3, #0
 80004fa:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80004fc:	e002      	b.n	8000504 <LoopCopyDataInit>

080004fe <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80004fe:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000500:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000502:	3304      	adds	r3, #4

08000504 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000504:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000506:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000508:	d3f9      	bcc.n	80004fe <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800050a:	4a0b      	ldr	r2, [pc, #44]	; (8000538 <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 800050c:	4c0b      	ldr	r4, [pc, #44]	; (800053c <LoopFillZerobss+0x26>)
  movs r3, #0
 800050e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000510:	e001      	b.n	8000516 <LoopFillZerobss>

08000512 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000512:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000514:	3204      	adds	r2, #4

08000516 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000516:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000518:	d3fb      	bcc.n	8000512 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800051a:	f000 f9c5 	bl	80008a8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800051e:	f001 fc3d 	bl	8001d9c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000522:	f000 f8e9 	bl	80006f8 <main>
  bx  lr    
 8000526:	4770      	bx	lr
  ldr   sp, =_estack       /* set stack pointer */
 8000528:	20030000 	.word	0x20030000
  ldr r0, =_sdata
 800052c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000530:	20000054 	.word	0x20000054
  ldr r2, =_sidata
 8000534:	08001e3c 	.word	0x08001e3c
  ldr r2, =_sbss
 8000538:	20000054 	.word	0x20000054
  ldr r4, =_ebss
 800053c:	20000164 	.word	0x20000164

08000540 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000540:	e7fe      	b.n	8000540 <ADC_IRQHandler>

08000542 <UserDataTreatment>:
  * @param  huart UART handle.
  * @param  pData Pointer on received data buffer to be processed
  * @retval Size  Nb of received characters available in buffer
  */
void UserDataTreatment(UART_HandleTypeDef *huart, uint8_t* pData, uint16_t Size)
{
 8000542:	b530      	push	{r4, r5, lr}
  uint8_t  i;

  /* Implementation of loopback is on purpose implemented in direct register access,
     in order to be able to echo received characters as fast as they are received.
     Wait for TC flag to be raised at end of transmit is then removed, only TXE is checked */
  for (i = 0; i < Size; i++)
 8000544:	2300      	movs	r3, #0
 8000546:	b2dc      	uxtb	r4, r3
 8000548:	4294      	cmp	r4, r2
 800054a:	d300      	bcc.n	800054e <UserDataTreatment+0xc>
    while (!(__HAL_UART_GET_FLAG(huart, UART_FLAG_TXE))) {}
    huart->Instance->DR = *pBuff;
    pBuff++;
  }

}
 800054c:	bd30      	pop	{r4, r5, pc}
    while (!(__HAL_UART_GET_FLAG(huart, UART_FLAG_TXE))) {}
 800054e:	6804      	ldr	r4, [r0, #0]
 8000550:	6825      	ldr	r5, [r4, #0]
 8000552:	062d      	lsls	r5, r5, #24
 8000554:	d5fc      	bpl.n	8000550 <UserDataTreatment+0xe>
    huart->Instance->DR = *pBuff;
 8000556:	5ccd      	ldrb	r5, [r1, r3]
 8000558:	6065      	str	r5, [r4, #4]
  for (i = 0; i < Size; i++)
 800055a:	3301      	adds	r3, #1
 800055c:	e7f3      	b.n	8000546 <UserDataTreatment+0x4>
	...

08000560 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8000560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  static uint8_t old_pos = 0;
  uint8_t *ptemp;
  uint8_t i;

  /* Check if number of received data in reception buffer has changed */
  if (Size != old_pos)
 8000562:	4c22      	ldr	r4, [pc, #136]	; (80005ec <HAL_UARTEx_RxEventCallback+0x8c>)
 8000564:	7823      	ldrb	r3, [r4, #0]
 8000566:	428b      	cmp	r3, r1
{
 8000568:	460d      	mov	r5, r1
  if (Size != old_pos)
 800056a:	d014      	beq.n	8000596 <HAL_UARTEx_RxEventCallback+0x36>
  {
    /* Check if position of index in reception buffer has simply be increased
       of if end of buffer has been reached */
    if (Size > old_pos)
 800056c:	d219      	bcs.n	80005a2 <HAL_UARTEx_RxEventCallback+0x42>
    {
      /* Current position is higher than previous one */
      uwNbReceivedChars = Size - old_pos;
 800056e:	1aca      	subs	r2, r1, r3
 8000570:	6062      	str	r2, [r4, #4]
      /* Copy received data in "User" buffer for evacuation */
      for (i = 0; i < uwNbReceivedChars; i++)
      {
        pBufferReadyForUser[i] = aRXBufferUser[old_pos + i];
 8000572:	4423      	add	r3, r4
      for (i = 0; i < uwNbReceivedChars; i++)
 8000574:	2200      	movs	r2, #0
 8000576:	6866      	ldr	r6, [r4, #4]
        pBufferReadyForUser[i] = aRXBufferUser[old_pos + i];
 8000578:	69e7      	ldr	r7, [r4, #28]
 800057a:	b2d1      	uxtb	r1, r2
      for (i = 0; i < uwNbReceivedChars; i++)
 800057c:	428e      	cmp	r6, r1
 800057e:	f102 0201 	add.w	r2, r2, #1
 8000582:	d80a      	bhi.n	800059a <HAL_UARTEx_RxEventCallback+0x3a>
        }
        uwNbReceivedChars += Size;
      }
    }
    /* Process received data that has been extracted from Rx User buffer */
    UserDataTreatment(huart, pBufferReadyForUser, uwNbReceivedChars);
 8000584:	6862      	ldr	r2, [r4, #4]
 8000586:	69e1      	ldr	r1, [r4, #28]
 8000588:	b292      	uxth	r2, r2
 800058a:	f7ff ffda 	bl	8000542 <UserDataTreatment>

    /* Swap buffers for next bytes to be processed */
    ptemp = pBufferReadyForUser;
    pBufferReadyForUser = pBufferReadyForReception;
 800058e:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
    pBufferReadyForReception = ptemp;
 8000592:	e9c4 2307 	strd	r2, r3, [r4, #28]
  }
  /* Update old_pos as new reference of position in User Rx buffer that
     indicates position to which data have been processed */
  old_pos = Size;
 8000596:	7025      	strb	r5, [r4, #0]

}
 8000598:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pBufferReadyForUser[i] = aRXBufferUser[old_pos + i];
 800059a:	185e      	adds	r6, r3, r1
 800059c:	7a36      	ldrb	r6, [r6, #8]
 800059e:	547e      	strb	r6, [r7, r1]
      for (i = 0; i < uwNbReceivedChars; i++)
 80005a0:	e7e9      	b.n	8000576 <HAL_UARTEx_RxEventCallback+0x16>
      uwNbReceivedChars = RX_BUFFER_SIZE - old_pos;
 80005a2:	f1c3 0214 	rsb	r2, r3, #20
 80005a6:	6062      	str	r2, [r4, #4]
        pBufferReadyForUser[i] = aRXBufferUser[old_pos + i];
 80005a8:	4423      	add	r3, r4
      for (i = 0; i < uwNbReceivedChars; i++)
 80005aa:	2200      	movs	r2, #0
 80005ac:	6866      	ldr	r6, [r4, #4]
        pBufferReadyForUser[i] = aRXBufferUser[old_pos + i];
 80005ae:	69e7      	ldr	r7, [r4, #28]
 80005b0:	b2d1      	uxtb	r1, r2
      for (i = 0; i < uwNbReceivedChars; i++)
 80005b2:	428e      	cmp	r6, r1
 80005b4:	f102 0201 	add.w	r2, r2, #1
 80005b8:	d803      	bhi.n	80005c2 <HAL_UARTEx_RxEventCallback+0x62>
      if (Size > 0)
 80005ba:	2d00      	cmp	r5, #0
 80005bc:	d0e2      	beq.n	8000584 <HAL_UARTEx_RxEventCallback+0x24>
 80005be:	2300      	movs	r3, #0
 80005c0:	e009      	b.n	80005d6 <HAL_UARTEx_RxEventCallback+0x76>
        pBufferReadyForUser[i] = aRXBufferUser[old_pos + i];
 80005c2:	185e      	adds	r6, r3, r1
 80005c4:	7a36      	ldrb	r6, [r6, #8]
 80005c6:	547e      	strb	r6, [r7, r1]
      for (i = 0; i < uwNbReceivedChars; i++)
 80005c8:	e7f0      	b.n	80005ac <HAL_UARTEx_RxEventCallback+0x4c>
          pBufferReadyForUser[uwNbReceivedChars + i] = aRXBufferUser[i];
 80005ca:	6867      	ldr	r7, [r4, #4]
 80005cc:	1863      	adds	r3, r4, r1
 80005ce:	443a      	add	r2, r7
 80005d0:	7a1b      	ldrb	r3, [r3, #8]
 80005d2:	5453      	strb	r3, [r2, r1]
 80005d4:	4633      	mov	r3, r6
        for (i = 0; i < Size; i++)
 80005d6:	b2d9      	uxtb	r1, r3
 80005d8:	42a9      	cmp	r1, r5
          pBufferReadyForUser[uwNbReceivedChars + i] = aRXBufferUser[i];
 80005da:	69e2      	ldr	r2, [r4, #28]
        for (i = 0; i < Size; i++)
 80005dc:	f103 0601 	add.w	r6, r3, #1
 80005e0:	d3f3      	bcc.n	80005ca <HAL_UARTEx_RxEventCallback+0x6a>
        uwNbReceivedChars += Size;
 80005e2:	6863      	ldr	r3, [r4, #4]
 80005e4:	442b      	add	r3, r5
 80005e6:	6063      	str	r3, [r4, #4]
 80005e8:	e7cc      	b.n	8000584 <HAL_UARTEx_RxEventCallback+0x24>
 80005ea:	bf00      	nop
 80005ec:	20000070 	.word	0x20000070

080005f0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80005f0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while (1)
  {
    /* Toggle LED2 for error */
    BSP_LED_Toggle(LED2);
 80005f2:	2000      	movs	r0, #0
 80005f4:	f000 f950 	bl	8000898 <BSP_LED_Toggle>
    HAL_Delay(500);
 80005f8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80005fc:	f000 f9b0 	bl	8000960 <HAL_Delay>
  while (1)
 8000600:	e7f7      	b.n	80005f2 <Error_Handler+0x2>
	...

08000604 <SystemClock_Config>:
{
 8000604:	b510      	push	{r4, lr}
 8000606:	b094      	sub	sp, #80	; 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000608:	2214      	movs	r2, #20
 800060a:	2100      	movs	r1, #0
 800060c:	a809      	add	r0, sp, #36	; 0x24
 800060e:	f001 fbe9 	bl	8001de4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000612:	2214      	movs	r2, #20
 8000614:	2100      	movs	r1, #0
 8000616:	a803      	add	r0, sp, #12
 8000618:	f001 fbe4 	bl	8001de4 <memset>
  __HAL_RCC_PWR_CLK_ENABLE();
 800061c:	2300      	movs	r3, #0
 800061e:	4a20      	ldr	r2, [pc, #128]	; (80006a0 <SystemClock_Config+0x9c>)
 8000620:	9301      	str	r3, [sp, #4]
 8000622:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8000624:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8000628:	6411      	str	r1, [r2, #64]	; 0x40
 800062a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800062c:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8000630:	9201      	str	r2, [sp, #4]
 8000632:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000634:	4a1b      	ldr	r2, [pc, #108]	; (80006a4 <SystemClock_Config+0xa0>)
 8000636:	9302      	str	r3, [sp, #8]
 8000638:	6811      	ldr	r1, [r2, #0]
 800063a:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
 800063e:	6011      	str	r1, [r2, #0]
 8000640:	6812      	ldr	r2, [r2, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000642:	2402      	movs	r4, #2
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000644:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
  RCC_OscInitStruct.PLL.PLLN = 180;
 8000648:	2008      	movs	r0, #8
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800064a:	e9cd 430e 	strd	r4, r3, [sp, #56]	; 0x38
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800064e:	9202      	str	r2, [sp, #8]
  RCC_OscInitStruct.PLL.PLLN = 180;
 8000650:	23b4      	movs	r3, #180	; 0xb4
 8000652:	e9cd 0310 	strd	r0, r3, [sp, #64]	; 0x40
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000656:	9a02      	ldr	r2, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000658:	9408      	str	r4, [sp, #32]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800065a:	2101      	movs	r1, #1
 800065c:	2210      	movs	r2, #16
  RCC_OscInitStruct.PLL.PLLQ = 4;
 800065e:	2304      	movs	r3, #4
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000660:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000662:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8000666:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 4;
 8000668:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800066a:	f000 fd01 	bl	8001070 <HAL_RCC_OscConfig>
 800066e:	b108      	cbz	r0, 8000674 <SystemClock_Config+0x70>
    Error_Handler();
 8000670:	f7ff ffbe 	bl	80005f0 <Error_Handler>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 8000674:	f000 fcc2 	bl	8000ffc <HAL_PWREx_EnableOverDrive>
 8000678:	2800      	cmp	r0, #0
 800067a:	d1f9      	bne.n	8000670 <SystemClock_Config+0x6c>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800067c:	230f      	movs	r3, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800067e:	e9cd 3403 	strd	r3, r4, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000682:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000684:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
 8000688:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 800068c:	2105      	movs	r1, #5
 800068e:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000690:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000694:	f000 feca 	bl	800142c <HAL_RCC_ClockConfig>
 8000698:	2800      	cmp	r0, #0
 800069a:	d1e9      	bne.n	8000670 <SystemClock_Config+0x6c>
}
 800069c:	b014      	add	sp, #80	; 0x50
 800069e:	bd10      	pop	{r4, pc}
 80006a0:	40023800 	.word	0x40023800
 80006a4:	40007000 	.word	0x40007000

080006a8 <PrintInfo>:
{
 80006a8:	b508      	push	{r3, lr}
  if (HAL_OK != HAL_UART_Transmit(huart, String, Size, 100))
 80006aa:	2364      	movs	r3, #100	; 0x64
 80006ac:	f001 f86a 	bl	8001784 <HAL_UART_Transmit>
 80006b0:	b108      	cbz	r0, 80006b6 <PrintInfo+0xe>
    Error_Handler();
 80006b2:	f7ff ff9d 	bl	80005f0 <Error_Handler>
}
 80006b6:	bd08      	pop	{r3, pc}

080006b8 <StartReception>:
{
 80006b8:	b510      	push	{r4, lr}
  pBufferReadyForReception = aRXBufferA;
 80006ba:	4c0d      	ldr	r4, [pc, #52]	; (80006f0 <StartReception+0x38>)
  PrintInfo(&huart3, aTextInfoStart, COUNTOF(aTextInfoStart));
 80006bc:	490d      	ldr	r1, [pc, #52]	; (80006f4 <StartReception+0x3c>)
  pBufferReadyForReception = aRXBufferA;
 80006be:	f104 0324 	add.w	r3, r4, #36	; 0x24
 80006c2:	6223      	str	r3, [r4, #32]
  pBufferReadyForUser      = aRXBufferB;
 80006c4:	f104 0338 	add.w	r3, r4, #56	; 0x38
 80006c8:	61e3      	str	r3, [r4, #28]
  PrintInfo(&huart3, aTextInfoStart, COUNTOF(aTextInfoStart));
 80006ca:	2240      	movs	r2, #64	; 0x40
  uwNbReceivedChars        = 0;
 80006cc:	2300      	movs	r3, #0
  PrintInfo(&huart3, aTextInfoStart, COUNTOF(aTextInfoStart));
 80006ce:	f104 004c 	add.w	r0, r4, #76	; 0x4c
  uwNbReceivedChars        = 0;
 80006d2:	6063      	str	r3, [r4, #4]
  PrintInfo(&huart3, aTextInfoStart, COUNTOF(aTextInfoStart));
 80006d4:	f7ff ffe8 	bl	80006a8 <PrintInfo>
  if (HAL_OK != HAL_UARTEx_ReceiveToIdle_DMA(&huart3, aRXBufferUser, RX_BUFFER_SIZE))
 80006d8:	2214      	movs	r2, #20
 80006da:	f104 0108 	add.w	r1, r4, #8
 80006de:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 80006e2:	f001 fb29 	bl	8001d38 <HAL_UARTEx_ReceiveToIdle_DMA>
 80006e6:	b108      	cbz	r0, 80006ec <StartReception+0x34>
    Error_Handler();
 80006e8:	f7ff ff82 	bl	80005f0 <Error_Handler>
}
 80006ec:	bd10      	pop	{r4, pc}
 80006ee:	bf00      	nop
 80006f0:	20000070 	.word	0x20000070
 80006f4:	20000000 	.word	0x20000000

080006f8 <main>:
{
 80006f8:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80006fa:	2400      	movs	r4, #0
  HAL_Init();
 80006fc:	f000 f904 	bl	8000908 <HAL_Init>
  SystemClock_Config();
 8000700:	f7ff ff80 	bl	8000604 <SystemClock_Config>
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000704:	4b19      	ldr	r3, [pc, #100]	; (800076c <main+0x74>)
 8000706:	9401      	str	r4, [sp, #4]
 8000708:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800070a:	f042 0208 	orr.w	r2, r2, #8
 800070e:	631a      	str	r2, [r3, #48]	; 0x30
 8000710:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000712:	f002 0208 	and.w	r2, r2, #8
 8000716:	9201      	str	r2, [sp, #4]
 8000718:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_DMA1_CLK_ENABLE();
 800071a:	9400      	str	r4, [sp, #0]
 800071c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800071e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8000722:	631a      	str	r2, [r3, #48]	; 0x30
 8000724:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000726:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 800072a:	4622      	mov	r2, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 800072c:	9300      	str	r3, [sp, #0]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 800072e:	4621      	mov	r1, r4
 8000730:	200c      	movs	r0, #12
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000732:	9b00      	ldr	r3, [sp, #0]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 8000734:	f000 f93a 	bl	80009ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8000738:	200c      	movs	r0, #12
 800073a:	f000 f969 	bl	8000a10 <HAL_NVIC_EnableIRQ>
  huart3.Instance = USART3;
 800073e:	480c      	ldr	r0, [pc, #48]	; (8000770 <main+0x78>)
  huart3.Init.BaudRate = 115200;
 8000740:	4a0c      	ldr	r2, [pc, #48]	; (8000774 <main+0x7c>)
  huart3.Init.Parity = UART_PARITY_NONE;
 8000742:	65c4      	str	r4, [r0, #92]	; 0x5c
  huart3.Init.BaudRate = 115200;
 8000744:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8000748:	e9c0 2313 	strd	r2, r3, [r0, #76]	; 0x4c
  huart3.Init.Mode = UART_MODE_TX_RX;
 800074c:	230c      	movs	r3, #12
  huart3.Init.StopBits = UART_STOPBITS_1;
 800074e:	e9c0 4415 	strd	r4, r4, [r0, #84]	; 0x54
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000752:	e9c0 3418 	strd	r3, r4, [r0, #96]	; 0x60
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 8000756:	6684      	str	r4, [r0, #104]	; 0x68
  if (HAL_UART_Init(&huart3) != HAL_OK)
 8000758:	304c      	adds	r0, #76	; 0x4c
 800075a:	f000 ffe5 	bl	8001728 <HAL_UART_Init>
 800075e:	b108      	cbz	r0, 8000764 <main+0x6c>
    Error_Handler();
 8000760:	f7ff ff46 	bl	80005f0 <Error_Handler>
  StartReception();  
 8000764:	f7ff ffa8 	bl	80006b8 <StartReception>
  while (1)
 8000768:	e7fe      	b.n	8000768 <main+0x70>
 800076a:	bf00      	nop
 800076c:	40023800 	.word	0x40023800
 8000770:	20000070 	.word	0x20000070
 8000774:	40004800 	.word	0x40004800

08000778 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000778:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800077a:	4b0c      	ldr	r3, [pc, #48]	; (80007ac <HAL_MspInit+0x34>)
 800077c:	2100      	movs	r1, #0
 800077e:	9100      	str	r1, [sp, #0]
 8000780:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000782:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000786:	645a      	str	r2, [r3, #68]	; 0x44
 8000788:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800078a:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 800078e:	9200      	str	r2, [sp, #0]
 8000790:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000792:	9101      	str	r1, [sp, #4]
 8000794:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000796:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800079a:	641a      	str	r2, [r3, #64]	; 0x40
 800079c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800079e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80007a2:	9301      	str	r3, [sp, #4]
 80007a4:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80007a6:	b002      	add	sp, #8
 80007a8:	4770      	bx	lr
 80007aa:	bf00      	nop
 80007ac:	40023800 	.word	0x40023800

080007b0 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80007b0:	b570      	push	{r4, r5, r6, lr}
 80007b2:	4606      	mov	r6, r0
 80007b4:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80007b6:	2214      	movs	r2, #20
 80007b8:	2100      	movs	r1, #0
 80007ba:	a803      	add	r0, sp, #12
 80007bc:	f001 fb12 	bl	8001de4 <memset>
  if(huart->Instance==USART3)
 80007c0:	6832      	ldr	r2, [r6, #0]
 80007c2:	4b26      	ldr	r3, [pc, #152]	; (800085c <HAL_UART_MspInit+0xac>)
 80007c4:	429a      	cmp	r2, r3
 80007c6:	d147      	bne.n	8000858 <HAL_UART_MspInit+0xa8>
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 80007c8:	2500      	movs	r5, #0
 80007ca:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
 80007ce:	9501      	str	r5, [sp, #4]
 80007d0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80007d2:	4823      	ldr	r0, [pc, #140]	; (8000860 <HAL_UART_MspInit+0xb0>)

    /* USART3 DMA Init */
    /* USART3_RX Init */
    hdma_usart3_rx.Instance = DMA1_Stream1;
 80007d4:	4c23      	ldr	r4, [pc, #140]	; (8000864 <HAL_UART_MspInit+0xb4>)
    __HAL_RCC_USART3_CLK_ENABLE();
 80007d6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80007da:	641a      	str	r2, [r3, #64]	; 0x40
 80007dc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80007de:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 80007e2:	9201      	str	r2, [sp, #4]
 80007e4:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80007e6:	9502      	str	r5, [sp, #8]
 80007e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007ea:	f042 0208 	orr.w	r2, r2, #8
 80007ee:	631a      	str	r2, [r3, #48]	; 0x30
 80007f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80007f2:	f003 0308 	and.w	r3, r3, #8
 80007f6:	9302      	str	r3, [sp, #8]
 80007f8:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80007fa:	f44f 7240 	mov.w	r2, #768	; 0x300
 80007fe:	2302      	movs	r3, #2
 8000800:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000804:	2101      	movs	r1, #1
 8000806:	2303      	movs	r3, #3
 8000808:	e9cd 1305 	strd	r1, r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 800080c:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800080e:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8000810:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000812:	f000 fb03 	bl	8000e1c <HAL_GPIO_Init>
    hdma_usart3_rx.Init.Channel = DMA_CHANNEL_4;
 8000816:	4814      	ldr	r0, [pc, #80]	; (8000868 <HAL_UART_MspInit+0xb8>)
    hdma_usart3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8000818:	61a5      	str	r5, [r4, #24]
    hdma_usart3_rx.Init.Channel = DMA_CHANNEL_4;
 800081a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800081e:	e9c4 0300 	strd	r0, r3, [r4]
    hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
 8000822:	f44f 6380 	mov.w	r3, #1024	; 0x400
    hdma_usart3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000826:	e9c4 3504 	strd	r3, r5, [r4, #16]
    hdma_usart3_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart3_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_usart3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
 800082a:	4620      	mov	r0, r4
    hdma_usart3_rx.Init.Mode = DMA_CIRCULAR;
 800082c:	f44f 7380 	mov.w	r3, #256	; 0x100
    hdma_usart3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000830:	e9c4 5502 	strd	r5, r5, [r4, #8]
    hdma_usart3_rx.Init.Priority = DMA_PRIORITY_LOW;
 8000834:	e9c4 3507 	strd	r3, r5, [r4, #28]
    hdma_usart3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8000838:	6265      	str	r5, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
 800083a:	f000 f921 	bl	8000a80 <HAL_DMA_Init>
 800083e:	b108      	cbz	r0, 8000844 <HAL_UART_MspInit+0x94>
    {
      Error_Handler();
 8000840:	f7ff fed6 	bl	80005f0 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmarx,hdma_usart3_rx);

    /* USART3 interrupt Init */
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 0);
 8000844:	2200      	movs	r2, #0
    __HAL_LINKDMA(huart,hdmarx,hdma_usart3_rx);
 8000846:	63b4      	str	r4, [r6, #56]	; 0x38
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 0);
 8000848:	2027      	movs	r0, #39	; 0x27
 800084a:	4611      	mov	r1, r2
    __HAL_LINKDMA(huart,hdmarx,hdma_usart3_rx);
 800084c:	63a6      	str	r6, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 0);
 800084e:	f000 f8ad 	bl	80009ac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 8000852:	2027      	movs	r0, #39	; 0x27
 8000854:	f000 f8dc 	bl	8000a10 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 8000858:	b008      	add	sp, #32
 800085a:	bd70      	pop	{r4, r5, r6, pc}
 800085c:	40004800 	.word	0x40004800
 8000860:	40020c00 	.word	0x40020c00
 8000864:	20000100 	.word	0x20000100
 8000868:	40026028 	.word	0x40026028

0800086c <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 800086c:	4770      	bx	lr

0800086e <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800086e:	e7fe      	b.n	800086e <HardFault_Handler>

08000870 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000870:	e7fe      	b.n	8000870 <MemManage_Handler>

08000872 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000872:	e7fe      	b.n	8000872 <BusFault_Handler>

08000874 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000874:	e7fe      	b.n	8000874 <UsageFault_Handler>

08000876 <SVC_Handler>:
 8000876:	4770      	bx	lr

08000878 <DebugMon_Handler>:
 8000878:	4770      	bx	lr

0800087a <PendSV_Handler>:
 800087a:	4770      	bx	lr

0800087c <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800087c:	f000 b85e 	b.w	800093c <HAL_IncTick>

08000880 <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_rx);
 8000880:	4801      	ldr	r0, [pc, #4]	; (8000888 <DMA1_Stream1_IRQHandler+0x8>)
 8000882:	f000 ba0d 	b.w	8000ca0 <HAL_DMA_IRQHandler>
 8000886:	bf00      	nop
 8000888:	20000100 	.word	0x20000100

0800088c <USART3_IRQHandler>:
void USART3_IRQHandler(void)
{
  /* USER CODE BEGIN USART3_IRQn 0 */

  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
 800088c:	4801      	ldr	r0, [pc, #4]	; (8000894 <USART3_IRQHandler+0x8>)
 800088e:	f001 b8b5 	b.w	80019fc <HAL_UART_IRQHandler>
 8000892:	bf00      	nop
 8000894:	200000bc 	.word	0x200000bc

08000898 <BSP_LED_Toggle>:
  *   This parameter can be one of following parameters:
  *     @arg LED2  
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 8000898:	4b02      	ldr	r3, [pc, #8]	; (80008a4 <BSP_LED_Toggle+0xc>)
 800089a:	2120      	movs	r1, #32
 800089c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80008a0:	f000 bba2 	b.w	8000fe8 <HAL_GPIO_TogglePin>
 80008a4:	20000040 	.word	0x20000040

080008a8 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80008a8:	4b05      	ldr	r3, [pc, #20]	; (80008c0 <SystemInit+0x18>)
 80008aa:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80008ae:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80008b2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80008b6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80008ba:	609a      	str	r2, [r3, #8]
#endif
}
 80008bc:	4770      	bx	lr
 80008be:	bf00      	nop
 80008c0:	e000ed00 	.word	0xe000ed00

080008c4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80008c4:	b570      	push	{r4, r5, r6, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80008c6:	4a0e      	ldr	r2, [pc, #56]	; (8000900 <HAL_InitTick+0x3c>)
 80008c8:	4e0e      	ldr	r6, [pc, #56]	; (8000904 <HAL_InitTick+0x40>)
{
 80008ca:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80008cc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80008d0:	7830      	ldrb	r0, [r6, #0]
 80008d2:	fbb3 f3f0 	udiv	r3, r3, r0
 80008d6:	6810      	ldr	r0, [r2, #0]
 80008d8:	fbb0 f0f3 	udiv	r0, r0, r3
 80008dc:	f000 f8a6 	bl	8000a2c <HAL_SYSTICK_Config>
 80008e0:	4604      	mov	r4, r0
 80008e2:	b950      	cbnz	r0, 80008fa <HAL_InitTick+0x36>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80008e4:	2d0f      	cmp	r5, #15
 80008e6:	d808      	bhi.n	80008fa <HAL_InitTick+0x36>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80008e8:	4602      	mov	r2, r0
 80008ea:	4629      	mov	r1, r5
 80008ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80008f0:	f000 f85c 	bl	80009ac <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80008f4:	6075      	str	r5, [r6, #4]
 80008f6:	4620      	mov	r0, r4
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 80008f8:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 80008fa:	2001      	movs	r0, #1
 80008fc:	e7fc      	b.n	80008f8 <HAL_InitTick+0x34>
 80008fe:	bf00      	nop
 8000900:	20000048 	.word	0x20000048
 8000904:	2000004c 	.word	0x2000004c

08000908 <HAL_Init>:
{
 8000908:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800090a:	4b0b      	ldr	r3, [pc, #44]	; (8000938 <HAL_Init+0x30>)
 800090c:	681a      	ldr	r2, [r3, #0]
 800090e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000912:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8000914:	681a      	ldr	r2, [r3, #0]
 8000916:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800091a:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800091c:	681a      	ldr	r2, [r3, #0]
 800091e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000922:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000924:	2003      	movs	r0, #3
 8000926:	f000 f82f 	bl	8000988 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800092a:	2000      	movs	r0, #0
 800092c:	f7ff ffca 	bl	80008c4 <HAL_InitTick>
  HAL_MspInit();
 8000930:	f7ff ff22 	bl	8000778 <HAL_MspInit>
}
 8000934:	2000      	movs	r0, #0
 8000936:	bd08      	pop	{r3, pc}
 8000938:	40023c00 	.word	0x40023c00

0800093c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800093c:	4a03      	ldr	r2, [pc, #12]	; (800094c <HAL_IncTick+0x10>)
 800093e:	4b04      	ldr	r3, [pc, #16]	; (8000950 <HAL_IncTick+0x14>)
 8000940:	6811      	ldr	r1, [r2, #0]
 8000942:	781b      	ldrb	r3, [r3, #0]
 8000944:	440b      	add	r3, r1
 8000946:	6013      	str	r3, [r2, #0]
}
 8000948:	4770      	bx	lr
 800094a:	bf00      	nop
 800094c:	20000160 	.word	0x20000160
 8000950:	2000004c 	.word	0x2000004c

08000954 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000954:	4b01      	ldr	r3, [pc, #4]	; (800095c <HAL_GetTick+0x8>)
 8000956:	6818      	ldr	r0, [r3, #0]
}
 8000958:	4770      	bx	lr
 800095a:	bf00      	nop
 800095c:	20000160 	.word	0x20000160

08000960 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000960:	b538      	push	{r3, r4, r5, lr}
 8000962:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000964:	f7ff fff6 	bl	8000954 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000968:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 800096a:	bf1c      	itt	ne
 800096c:	4b05      	ldrne	r3, [pc, #20]	; (8000984 <HAL_Delay+0x24>)
 800096e:	781b      	ldrbne	r3, [r3, #0]
  uint32_t tickstart = HAL_GetTick();
 8000970:	4605      	mov	r5, r0
    wait += (uint32_t)(uwTickFreq);
 8000972:	bf18      	it	ne
 8000974:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000976:	f7ff ffed 	bl	8000954 <HAL_GetTick>
 800097a:	1b43      	subs	r3, r0, r5
 800097c:	42a3      	cmp	r3, r4
 800097e:	d3fa      	bcc.n	8000976 <HAL_Delay+0x16>
  {
  }
}
 8000980:	bd38      	pop	{r3, r4, r5, pc}
 8000982:	bf00      	nop
 8000984:	2000004c 	.word	0x2000004c

08000988 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000988:	4907      	ldr	r1, [pc, #28]	; (80009a8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800098a:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800098c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000990:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000992:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000994:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000998:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800099a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800099c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80009a0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80009a4:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80009a6:	4770      	bx	lr
 80009a8:	e000ed00 	.word	0xe000ed00

080009ac <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80009ac:	4b16      	ldr	r3, [pc, #88]	; (8000a08 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80009ae:	b530      	push	{r4, r5, lr}
 80009b0:	68dc      	ldr	r4, [r3, #12]
 80009b2:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80009b6:	f1c4 0507 	rsb	r5, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80009ba:	1d23      	adds	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80009bc:	2d04      	cmp	r5, #4
 80009be:	bf28      	it	cs
 80009c0:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80009c2:	2b06      	cmp	r3, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80009c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80009c8:	bf8c      	ite	hi
 80009ca:	3c03      	subhi	r4, #3
 80009cc:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80009ce:	fa03 f505 	lsl.w	r5, r3, r5
 80009d2:	ea21 0105 	bic.w	r1, r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80009d6:	40a3      	lsls	r3, r4
 80009d8:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80009dc:	40a1      	lsls	r1, r4
  if ((int32_t)(IRQn) >= 0)
 80009de:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80009e0:	ea41 0302 	orr.w	r3, r1, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009e4:	bfac      	ite	ge
 80009e6:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009ea:	4a08      	ldrlt	r2, [pc, #32]	; (8000a0c <HAL_NVIC_SetPriority+0x60>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009ec:	ea4f 1303 	mov.w	r3, r3, lsl #4
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009f0:	bfb8      	it	lt
 80009f2:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009f6:	b2db      	uxtb	r3, r3
 80009f8:	bfaa      	itet	ge
 80009fa:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009fe:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a00:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000a04:	bd30      	pop	{r4, r5, pc}
 8000a06:	bf00      	nop
 8000a08:	e000ed00 	.word	0xe000ed00
 8000a0c:	e000ed14 	.word	0xe000ed14

08000a10 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000a10:	2800      	cmp	r0, #0
 8000a12:	db08      	blt.n	8000a26 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000a14:	0942      	lsrs	r2, r0, #5
 8000a16:	2301      	movs	r3, #1
 8000a18:	f000 001f 	and.w	r0, r0, #31
 8000a1c:	fa03 f000 	lsl.w	r0, r3, r0
 8000a20:	4b01      	ldr	r3, [pc, #4]	; (8000a28 <HAL_NVIC_EnableIRQ+0x18>)
 8000a22:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000a26:	4770      	bx	lr
 8000a28:	e000e100 	.word	0xe000e100

08000a2c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000a2c:	3801      	subs	r0, #1
 8000a2e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000a32:	d20b      	bcs.n	8000a4c <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000a34:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a38:	4a05      	ldr	r2, [pc, #20]	; (8000a50 <HAL_SYSTICK_Config+0x24>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000a3a:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a3c:	21f0      	movs	r1, #240	; 0xf0
 8000a3e:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000a42:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000a44:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000a46:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000a48:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000a4a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000a4c:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000a4e:	4770      	bx	lr
 8000a50:	e000ed00 	.word	0xe000ed00

08000a54 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8000a54:	6803      	ldr	r3, [r0, #0]
{
 8000a56:	b510      	push	{r4, lr}
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8000a58:	4c08      	ldr	r4, [pc, #32]	; (8000a7c <DMA_CalcBaseAndBitshift+0x28>)
{
 8000a5a:	4602      	mov	r2, r0
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8000a5c:	b2d9      	uxtb	r1, r3
 8000a5e:	3910      	subs	r1, #16
 8000a60:	2018      	movs	r0, #24
 8000a62:	fbb1 f0f0 	udiv	r0, r1, r0
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8000a66:	5c20      	ldrb	r0, [r4, r0]
 8000a68:	65d0      	str	r0, [r2, #92]	; 0x5c
  
  if (stream_number > 3U)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8000a6a:	f423 707f 	bic.w	r0, r3, #1020	; 0x3fc
 8000a6e:	f020 0003 	bic.w	r0, r0, #3
  if (stream_number > 3U)
 8000a72:	295f      	cmp	r1, #95	; 0x5f
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8000a74:	bf88      	it	hi
 8000a76:	3004      	addhi	r0, #4
 8000a78:	6590      	str	r0, [r2, #88]	; 0x58
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }
  
  return hdma->StreamBaseAddress;
}
 8000a7a:	bd10      	pop	{r4, pc}
 8000a7c:	08001e24 	.word	0x08001e24

08000a80 <HAL_DMA_Init>:
{
 8000a80:	b570      	push	{r4, r5, r6, lr}
 8000a82:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000a84:	f7ff ff66 	bl	8000954 <HAL_GetTick>
 8000a88:	4605      	mov	r5, r0
  if(hdma == NULL)
 8000a8a:	2c00      	cmp	r4, #0
 8000a8c:	d073      	beq.n	8000b76 <HAL_DMA_Init+0xf6>
  hdma->State = HAL_DMA_STATE_BUSY;
 8000a8e:	2302      	movs	r3, #2
 8000a90:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 8000a94:	6822      	ldr	r2, [r4, #0]
  __HAL_UNLOCK(hdma);
 8000a96:	2300      	movs	r3, #0
 8000a98:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 8000a9c:	6813      	ldr	r3, [r2, #0]
 8000a9e:	f023 0301 	bic.w	r3, r3, #1
 8000aa2:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8000aa4:	6821      	ldr	r1, [r4, #0]
 8000aa6:	680b      	ldr	r3, [r1, #0]
 8000aa8:	07d8      	lsls	r0, r3, #31
 8000aaa:	d42f      	bmi.n	8000b0c <HAL_DMA_Init+0x8c>
  tmp = hdma->Instance->CR;
 8000aac:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000aae:	4d33      	ldr	r5, [pc, #204]	; (8000b7c <HAL_DMA_Init+0xfc>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000ab0:	69a0      	ldr	r0, [r4, #24]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000ab2:	401d      	ands	r5, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000ab4:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
 8000ab8:	4313      	orrs	r3, r2
 8000aba:	68e2      	ldr	r2, [r4, #12]
 8000abc:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000abe:	6922      	ldr	r2, [r4, #16]
 8000ac0:	4313      	orrs	r3, r2
 8000ac2:	6962      	ldr	r2, [r4, #20]
 8000ac4:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000ac6:	69e2      	ldr	r2, [r4, #28]
 8000ac8:	4303      	orrs	r3, r0
 8000aca:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
 8000acc:	6a22      	ldr	r2, [r4, #32]
 8000ace:	4313      	orrs	r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000ad0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000ad2:	2a04      	cmp	r2, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000ad4:	ea43 0305 	orr.w	r3, r3, r5
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8000ad8:	bf02      	ittt	eq
 8000ada:	e9d4 560b 	ldrdeq	r5, r6, [r4, #44]	; 0x2c
 8000ade:	4335      	orreq	r5, r6
 8000ae0:	432b      	orreq	r3, r5
  hdma->Instance->CR = tmp;  
 8000ae2:	600b      	str	r3, [r1, #0]
  tmp = hdma->Instance->FCR;
 8000ae4:	694b      	ldr	r3, [r1, #20]
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000ae6:	2a04      	cmp	r2, #4
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8000ae8:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma->Init.FIFOMode;
 8000aec:	ea43 0302 	orr.w	r3, r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000af0:	d133      	bne.n	8000b5a <HAL_DMA_Init+0xda>
    tmp |= hdma->Init.FIFOThreshold;
 8000af2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8000af4:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 8000af6:	4313      	orrs	r3, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8000af8:	b37d      	cbz	r5, 8000b5a <HAL_DMA_Init+0xda>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8000afa:	b990      	cbnz	r0, 8000b22 <HAL_DMA_Init+0xa2>
  {
    switch (tmp)
 8000afc:	2a01      	cmp	r2, #1
 8000afe:	d021      	beq.n	8000b44 <HAL_DMA_Init+0xc4>
 8000b00:	f032 0202 	bics.w	r2, r2, #2
 8000b04:	d129      	bne.n	8000b5a <HAL_DMA_Init+0xda>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8000b06:	01ea      	lsls	r2, r5, #7
 8000b08:	d527      	bpl.n	8000b5a <HAL_DMA_Init+0xda>
 8000b0a:	e01e      	b.n	8000b4a <HAL_DMA_Init+0xca>
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8000b0c:	f7ff ff22 	bl	8000954 <HAL_GetTick>
 8000b10:	1b40      	subs	r0, r0, r5
 8000b12:	2805      	cmp	r0, #5
 8000b14:	d9c6      	bls.n	8000aa4 <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8000b16:	2320      	movs	r3, #32
 8000b18:	6563      	str	r3, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8000b1a:	2003      	movs	r0, #3
        hdma->State = HAL_DMA_STATE_READY;
 8000b1c:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
 8000b20:	bd70      	pop	{r4, r5, r6, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8000b22:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8000b26:	d114      	bne.n	8000b52 <HAL_DMA_Init+0xd2>
    switch (tmp)
 8000b28:	2a03      	cmp	r2, #3
 8000b2a:	d816      	bhi.n	8000b5a <HAL_DMA_Init+0xda>
 8000b2c:	a001      	add	r0, pc, #4	; (adr r0, 8000b34 <HAL_DMA_Init+0xb4>)
 8000b2e:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 8000b32:	bf00      	nop
 8000b34:	08000b4b 	.word	0x08000b4b
 8000b38:	08000b07 	.word	0x08000b07
 8000b3c:	08000b4b 	.word	0x08000b4b
 8000b40:	08000b45 	.word	0x08000b45
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8000b44:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 8000b48:	d107      	bne.n	8000b5a <HAL_DMA_Init+0xda>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8000b4a:	2340      	movs	r3, #64	; 0x40
 8000b4c:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8000b4e:	2001      	movs	r0, #1
 8000b50:	e7e4      	b.n	8000b1c <HAL_DMA_Init+0x9c>
    switch (tmp)
 8000b52:	2a02      	cmp	r2, #2
 8000b54:	d9f9      	bls.n	8000b4a <HAL_DMA_Init+0xca>
 8000b56:	2a03      	cmp	r2, #3
 8000b58:	d0d5      	beq.n	8000b06 <HAL_DMA_Init+0x86>
  hdma->Instance->FCR = tmp;
 8000b5a:	614b      	str	r3, [r1, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8000b5c:	4620      	mov	r0, r4
 8000b5e:	f7ff ff79 	bl	8000a54 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000b62:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8000b64:	233f      	movs	r3, #63	; 0x3f
 8000b66:	4093      	lsls	r3, r2
 8000b68:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000b6a:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8000b6c:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000b6e:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8000b70:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8000b74:	e7d4      	b.n	8000b20 <HAL_DMA_Init+0xa0>
    return HAL_ERROR;
 8000b76:	2001      	movs	r0, #1
 8000b78:	e7d2      	b.n	8000b20 <HAL_DMA_Init+0xa0>
 8000b7a:	bf00      	nop
 8000b7c:	f010803f 	.word	0xf010803f

08000b80 <HAL_DMA_Start_IT>:
{
 8000b80:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 8000b82:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8000b86:	6d86      	ldr	r6, [r0, #88]	; 0x58
  __HAL_LOCK(hdma);
 8000b88:	2c01      	cmp	r4, #1
 8000b8a:	d031      	beq.n	8000bf0 <HAL_DMA_Start_IT+0x70>
 8000b8c:	2401      	movs	r4, #1
 8000b8e:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8000b92:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8000b96:	2c01      	cmp	r4, #1
 8000b98:	f04f 0500 	mov.w	r5, #0
 8000b9c:	f04f 0402 	mov.w	r4, #2
 8000ba0:	d124      	bne.n	8000bec <HAL_DMA_Start_IT+0x6c>
    hdma->State = HAL_DMA_STATE_BUSY;
 8000ba2:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8000ba6:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000ba8:	6545      	str	r5, [r0, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8000baa:	6825      	ldr	r5, [r4, #0]
 8000bac:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
 8000bb0:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 8000bb2:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8000bb4:	6883      	ldr	r3, [r0, #8]
 8000bb6:	2b40      	cmp	r3, #64	; 0x40
    hdma->Instance->PAR = DstAddress;
 8000bb8:	bf0e      	itee	eq
 8000bba:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->PAR = SrcAddress;
 8000bbc:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 8000bbe:	60e2      	strne	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000bc0:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
    hdma->Instance->M0AR = SrcAddress;
 8000bc2:	bf08      	it	eq
 8000bc4:	60e1      	streq	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000bc6:	233f      	movs	r3, #63	; 0x3f
 8000bc8:	4093      	lsls	r3, r2
 8000bca:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8000bcc:	6823      	ldr	r3, [r4, #0]
 8000bce:	f043 0316 	orr.w	r3, r3, #22
 8000bd2:	6023      	str	r3, [r4, #0]
    if(hdma->XferHalfCpltCallback != NULL)
 8000bd4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8000bd6:	b11b      	cbz	r3, 8000be0 <HAL_DMA_Start_IT+0x60>
      hdma->Instance->CR  |= DMA_IT_HT;
 8000bd8:	6823      	ldr	r3, [r4, #0]
 8000bda:	f043 0308 	orr.w	r3, r3, #8
 8000bde:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 8000be0:	6823      	ldr	r3, [r4, #0]
 8000be2:	f043 0301 	orr.w	r3, r3, #1
 8000be6:	6023      	str	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8000be8:	2000      	movs	r0, #0
}
 8000bea:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_UNLOCK(hdma);	  
 8000bec:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  __HAL_LOCK(hdma);
 8000bf0:	2002      	movs	r0, #2
 8000bf2:	e7fa      	b.n	8000bea <HAL_DMA_Start_IT+0x6a>

08000bf4 <HAL_DMA_Abort>:
{
 8000bf4:	b570      	push	{r4, r5, r6, lr}
 8000bf6:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8000bf8:	6d86      	ldr	r6, [r0, #88]	; 0x58
  uint32_t tickstart = HAL_GetTick();
 8000bfa:	f7ff feab 	bl	8000954 <HAL_GetTick>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000bfe:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 8000c02:	2b02      	cmp	r3, #2
  uint32_t tickstart = HAL_GetTick();
 8000c04:	4605      	mov	r5, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000c06:	d006      	beq.n	8000c16 <HAL_DMA_Abort+0x22>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000c08:	2380      	movs	r3, #128	; 0x80
 8000c0a:	6563      	str	r3, [r4, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 8000c0c:	2300      	movs	r3, #0
 8000c0e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return HAL_ERROR;
 8000c12:	2001      	movs	r0, #1
}
 8000c14:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8000c16:	6823      	ldr	r3, [r4, #0]
 8000c18:	681a      	ldr	r2, [r3, #0]
 8000c1a:	f022 0216 	bic.w	r2, r2, #22
 8000c1e:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 8000c20:	695a      	ldr	r2, [r3, #20]
 8000c22:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000c26:	615a      	str	r2, [r3, #20]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8000c28:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000c2a:	b90a      	cbnz	r2, 8000c30 <HAL_DMA_Abort+0x3c>
 8000c2c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8000c2e:	b11a      	cbz	r2, 8000c38 <HAL_DMA_Abort+0x44>
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 8000c30:	681a      	ldr	r2, [r3, #0]
 8000c32:	f022 0208 	bic.w	r2, r2, #8
 8000c36:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 8000c38:	681a      	ldr	r2, [r3, #0]
 8000c3a:	f022 0201 	bic.w	r2, r2, #1
 8000c3e:	601a      	str	r2, [r3, #0]
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8000c40:	6823      	ldr	r3, [r4, #0]
 8000c42:	681b      	ldr	r3, [r3, #0]
 8000c44:	f013 0301 	ands.w	r3, r3, #1
 8000c48:	d10a      	bne.n	8000c60 <HAL_DMA_Abort+0x6c>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000c4a:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8000c4c:	223f      	movs	r2, #63	; 0x3f
 8000c4e:	408a      	lsls	r2, r1
 8000c50:	60b2      	str	r2, [r6, #8]
    hdma->State = HAL_DMA_STATE_READY;
 8000c52:	2201      	movs	r2, #1
 8000c54:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
    __HAL_UNLOCK(hdma);
 8000c58:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
 8000c5c:	4618      	mov	r0, r3
 8000c5e:	e7d9      	b.n	8000c14 <HAL_DMA_Abort+0x20>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8000c60:	f7ff fe78 	bl	8000954 <HAL_GetTick>
 8000c64:	1b40      	subs	r0, r0, r5
 8000c66:	2805      	cmp	r0, #5
 8000c68:	d9ea      	bls.n	8000c40 <HAL_DMA_Abort+0x4c>
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8000c6a:	2320      	movs	r3, #32
 8000c6c:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8000c6e:	2003      	movs	r0, #3
        __HAL_UNLOCK(hdma);
 8000c70:	2300      	movs	r3, #0
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8000c72:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 8000c76:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        return HAL_TIMEOUT;
 8000c7a:	e7cb      	b.n	8000c14 <HAL_DMA_Abort+0x20>

08000c7c <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000c7c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8000c80:	2b02      	cmp	r3, #2
 8000c82:	d003      	beq.n	8000c8c <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000c84:	2380      	movs	r3, #128	; 0x80
 8000c86:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8000c88:	2001      	movs	r0, #1
 8000c8a:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 8000c8c:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8000c8e:	2305      	movs	r3, #5
 8000c90:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8000c94:	6813      	ldr	r3, [r2, #0]
 8000c96:	f023 0301 	bic.w	r3, r3, #1
 8000c9a:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8000c9c:	2000      	movs	r0, #0
}
 8000c9e:	4770      	bx	lr

08000ca0 <HAL_DMA_IRQHandler>:
{
 8000ca0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t count = 0U;
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	9301      	str	r3, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 8000ca6:	4b5c      	ldr	r3, [pc, #368]	; (8000e18 <HAL_DMA_IRQHandler+0x178>)
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8000ca8:	6d85      	ldr	r5, [r0, #88]	; 0x58
  uint32_t timeout = SystemCoreClock / 9600U;
 8000caa:	681f      	ldr	r7, [r3, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cac:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  tmpisr = regs->ISR;
 8000cae:	682e      	ldr	r6, [r5, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cb0:	2208      	movs	r2, #8
 8000cb2:	409a      	lsls	r2, r3
 8000cb4:	4232      	tst	r2, r6
{
 8000cb6:	4604      	mov	r4, r0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cb8:	d00c      	beq.n	8000cd4 <HAL_DMA_IRQHandler+0x34>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8000cba:	6801      	ldr	r1, [r0, #0]
 8000cbc:	6808      	ldr	r0, [r1, #0]
 8000cbe:	0740      	lsls	r0, r0, #29
 8000cc0:	d508      	bpl.n	8000cd4 <HAL_DMA_IRQHandler+0x34>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8000cc2:	6808      	ldr	r0, [r1, #0]
 8000cc4:	f020 0004 	bic.w	r0, r0, #4
 8000cc8:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8000cca:	60aa      	str	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8000ccc:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8000cce:	f042 0201 	orr.w	r2, r2, #1
 8000cd2:	6562      	str	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cd4:	2201      	movs	r2, #1
 8000cd6:	409a      	lsls	r2, r3
 8000cd8:	4232      	tst	r2, r6
 8000cda:	d008      	beq.n	8000cee <HAL_DMA_IRQHandler+0x4e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8000cdc:	6821      	ldr	r1, [r4, #0]
 8000cde:	6949      	ldr	r1, [r1, #20]
 8000ce0:	0609      	lsls	r1, r1, #24
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8000ce2:	bf41      	itttt	mi
 8000ce4:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8000ce6:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8000ce8:	f042 0202 	orrmi.w	r2, r2, #2
 8000cec:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8000cee:	2204      	movs	r2, #4
 8000cf0:	409a      	lsls	r2, r3
 8000cf2:	4232      	tst	r2, r6
 8000cf4:	d008      	beq.n	8000d08 <HAL_DMA_IRQHandler+0x68>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8000cf6:	6821      	ldr	r1, [r4, #0]
 8000cf8:	6809      	ldr	r1, [r1, #0]
 8000cfa:	0788      	lsls	r0, r1, #30
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8000cfc:	bf41      	itttt	mi
 8000cfe:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8000d00:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8000d02:	f042 0204 	orrmi.w	r2, r2, #4
 8000d06:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8000d08:	2210      	movs	r2, #16
 8000d0a:	409a      	lsls	r2, r3
 8000d0c:	4232      	tst	r2, r6
 8000d0e:	d010      	beq.n	8000d32 <HAL_DMA_IRQHandler+0x92>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8000d10:	6823      	ldr	r3, [r4, #0]
 8000d12:	6819      	ldr	r1, [r3, #0]
 8000d14:	0709      	lsls	r1, r1, #28
 8000d16:	d50c      	bpl.n	8000d32 <HAL_DMA_IRQHandler+0x92>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8000d18:	60aa      	str	r2, [r5, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8000d1a:	681a      	ldr	r2, [r3, #0]
 8000d1c:	0350      	lsls	r0, r2, #13
 8000d1e:	d537      	bpl.n	8000d90 <HAL_DMA_IRQHandler+0xf0>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8000d20:	681b      	ldr	r3, [r3, #0]
 8000d22:	0319      	lsls	r1, r3, #12
 8000d24:	d401      	bmi.n	8000d2a <HAL_DMA_IRQHandler+0x8a>
        if(hdma->XferHalfCpltCallback != NULL)
 8000d26:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000d28:	e000      	b.n	8000d2c <HAL_DMA_IRQHandler+0x8c>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8000d2a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
        if(hdma->XferHalfCpltCallback != NULL)
 8000d2c:	b10b      	cbz	r3, 8000d32 <HAL_DMA_IRQHandler+0x92>
          hdma->XferHalfCpltCallback(hdma);
 8000d2e:	4620      	mov	r0, r4
 8000d30:	4798      	blx	r3
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8000d32:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8000d34:	2220      	movs	r2, #32
 8000d36:	408a      	lsls	r2, r1
 8000d38:	4232      	tst	r2, r6
 8000d3a:	d03a      	beq.n	8000db2 <HAL_DMA_IRQHandler+0x112>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8000d3c:	6823      	ldr	r3, [r4, #0]
 8000d3e:	6818      	ldr	r0, [r3, #0]
 8000d40:	06c6      	lsls	r6, r0, #27
 8000d42:	d536      	bpl.n	8000db2 <HAL_DMA_IRQHandler+0x112>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8000d44:	60aa      	str	r2, [r5, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8000d46:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8000d4a:	2a05      	cmp	r2, #5
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8000d4c:	681a      	ldr	r2, [r3, #0]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8000d4e:	d127      	bne.n	8000da0 <HAL_DMA_IRQHandler+0x100>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8000d50:	f022 0216 	bic.w	r2, r2, #22
 8000d54:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8000d56:	695a      	ldr	r2, [r3, #20]
 8000d58:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000d5c:	615a      	str	r2, [r3, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8000d5e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000d60:	b90a      	cbnz	r2, 8000d66 <HAL_DMA_IRQHandler+0xc6>
 8000d62:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8000d64:	b11a      	cbz	r2, 8000d6e <HAL_DMA_IRQHandler+0xce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8000d66:	681a      	ldr	r2, [r3, #0]
 8000d68:	f022 0208 	bic.w	r2, r2, #8
 8000d6c:	601a      	str	r2, [r3, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000d6e:	233f      	movs	r3, #63	; 0x3f
 8000d70:	408b      	lsls	r3, r1
 8000d72:	60ab      	str	r3, [r5, #8]
        hdma->State = HAL_DMA_STATE_READY;
 8000d74:	2301      	movs	r3, #1
 8000d76:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 8000d7a:	2300      	movs	r3, #0
 8000d7c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        if(hdma->XferAbortCallback != NULL)
 8000d80:	6d23      	ldr	r3, [r4, #80]	; 0x50
    if(hdma->XferErrorCallback != NULL)
 8000d82:	2b00      	cmp	r3, #0
 8000d84:	d045      	beq.n	8000e12 <HAL_DMA_IRQHandler+0x172>
      hdma->XferErrorCallback(hdma);
 8000d86:	4620      	mov	r0, r4
}
 8000d88:	b003      	add	sp, #12
 8000d8a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      hdma->XferErrorCallback(hdma);
 8000d8e:	4718      	bx	r3
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8000d90:	681a      	ldr	r2, [r3, #0]
 8000d92:	05d2      	lsls	r2, r2, #23
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8000d94:	bf5e      	ittt	pl
 8000d96:	681a      	ldrpl	r2, [r3, #0]
 8000d98:	f022 0208 	bicpl.w	r2, r2, #8
 8000d9c:	601a      	strpl	r2, [r3, #0]
 8000d9e:	e7c2      	b.n	8000d26 <HAL_DMA_IRQHandler+0x86>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8000da0:	0350      	lsls	r0, r2, #13
 8000da2:	d527      	bpl.n	8000df4 <HAL_DMA_IRQHandler+0x154>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8000da4:	681b      	ldr	r3, [r3, #0]
 8000da6:	0319      	lsls	r1, r3, #12
 8000da8:	d431      	bmi.n	8000e0e <HAL_DMA_IRQHandler+0x16e>
          if(hdma->XferM1CpltCallback != NULL)
 8000daa:	6c63      	ldr	r3, [r4, #68]	; 0x44
        if(hdma->XferCpltCallback != NULL)
 8000dac:	b10b      	cbz	r3, 8000db2 <HAL_DMA_IRQHandler+0x112>
          hdma->XferCpltCallback(hdma);
 8000dae:	4620      	mov	r0, r4
 8000db0:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8000db2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000db4:	b36b      	cbz	r3, 8000e12 <HAL_DMA_IRQHandler+0x172>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8000db6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000db8:	07da      	lsls	r2, r3, #31
 8000dba:	d519      	bpl.n	8000df0 <HAL_DMA_IRQHandler+0x150>
      __HAL_DMA_DISABLE(hdma);
 8000dbc:	6822      	ldr	r2, [r4, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 8000dbe:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8000dc2:	fbb7 f7f3 	udiv	r7, r7, r3
      hdma->State = HAL_DMA_STATE_ABORT;
 8000dc6:	2305      	movs	r3, #5
 8000dc8:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8000dcc:	6813      	ldr	r3, [r2, #0]
 8000dce:	f023 0301 	bic.w	r3, r3, #1
 8000dd2:	6013      	str	r3, [r2, #0]
        if (++count > timeout)
 8000dd4:	9b01      	ldr	r3, [sp, #4]
 8000dd6:	3301      	adds	r3, #1
 8000dd8:	42bb      	cmp	r3, r7
 8000dda:	9301      	str	r3, [sp, #4]
 8000ddc:	d802      	bhi.n	8000de4 <HAL_DMA_IRQHandler+0x144>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8000dde:	6813      	ldr	r3, [r2, #0]
 8000de0:	07db      	lsls	r3, r3, #31
 8000de2:	d4f7      	bmi.n	8000dd4 <HAL_DMA_IRQHandler+0x134>
      hdma->State = HAL_DMA_STATE_READY;
 8000de4:	2301      	movs	r3, #1
 8000de6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 8000dea:	2300      	movs	r3, #0
 8000dec:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    if(hdma->XferErrorCallback != NULL)
 8000df0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000df2:	e7c6      	b.n	8000d82 <HAL_DMA_IRQHandler+0xe2>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8000df4:	681a      	ldr	r2, [r3, #0]
 8000df6:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 8000dfa:	d108      	bne.n	8000e0e <HAL_DMA_IRQHandler+0x16e>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8000dfc:	6819      	ldr	r1, [r3, #0]
 8000dfe:	f021 0110 	bic.w	r1, r1, #16
 8000e02:	6019      	str	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8000e04:	2301      	movs	r3, #1
 8000e06:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
          __HAL_UNLOCK(hdma);
 8000e0a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        if(hdma->XferCpltCallback != NULL)
 8000e0e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000e10:	e7cc      	b.n	8000dac <HAL_DMA_IRQHandler+0x10c>
}
 8000e12:	b003      	add	sp, #12
 8000e14:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e16:	bf00      	nop
 8000e18:	20000048 	.word	0x20000048

08000e1c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000e1c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000e20:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 8000fe4 <HAL_GPIO_Init+0x1c8>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000e24:	4a6d      	ldr	r2, [pc, #436]	; (8000fdc <HAL_GPIO_Init+0x1c0>)
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000e26:	2300      	movs	r3, #0
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000e28:	680d      	ldr	r5, [r1, #0]
    ioposition = 0x01U << position;
 8000e2a:	2401      	movs	r4, #1
 8000e2c:	409c      	lsls	r4, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000e2e:	ea04 0c05 	and.w	ip, r4, r5
    if(iocurrent == ioposition)
 8000e32:	43ac      	bics	r4, r5
 8000e34:	f040 80b9 	bne.w	8000faa <HAL_GPIO_Init+0x18e>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8000e38:	684d      	ldr	r5, [r1, #4]
 8000e3a:	f005 0403 	and.w	r4, r5, #3
 8000e3e:	ea4f 0843 	mov.w	r8, r3, lsl #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000e42:	2603      	movs	r6, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8000e44:	1e67      	subs	r7, r4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000e46:	fa06 f608 	lsl.w	r6, r6, r8
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8000e4a:	2f01      	cmp	r7, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000e4c:	ea6f 0606 	mvn.w	r6, r6
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8000e50:	d834      	bhi.n	8000ebc <HAL_GPIO_Init+0xa0>
        temp = GPIOx->OSPEEDR; 
 8000e52:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000e54:	ea07 0e06 	and.w	lr, r7, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000e58:	68cf      	ldr	r7, [r1, #12]
 8000e5a:	fa07 f708 	lsl.w	r7, r7, r8
 8000e5e:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OSPEEDR = temp;
 8000e62:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8000e64:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000e66:	ea27 0e0c 	bic.w	lr, r7, ip
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8000e6a:	f3c5 1700 	ubfx	r7, r5, #4, #1
 8000e6e:	409f      	lsls	r7, r3
 8000e70:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8000e74:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 8000e76:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000e78:	ea07 0e06 	and.w	lr, r7, r6
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000e7c:	688f      	ldr	r7, [r1, #8]
 8000e7e:	fa07 f708 	lsl.w	r7, r7, r8
 8000e82:	ea47 070e 	orr.w	r7, r7, lr
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8000e86:	2c02      	cmp	r4, #2
        GPIOx->PUPDR = temp;
 8000e88:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8000e8a:	d119      	bne.n	8000ec0 <HAL_GPIO_Init+0xa4>
        temp = GPIOx->AFR[position >> 3U];
 8000e8c:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8000e90:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000e94:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8000e98:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000e9c:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8000ea0:	f04f 0e0f 	mov.w	lr, #15
 8000ea4:	fa0e fe0b 	lsl.w	lr, lr, fp
 8000ea8:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8000eac:	690f      	ldr	r7, [r1, #16]
 8000eae:	fa07 f70b 	lsl.w	r7, r7, fp
 8000eb2:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->AFR[position >> 3U] = temp;
 8000eb6:	f8ca 7020 	str.w	r7, [sl, #32]
 8000eba:	e001      	b.n	8000ec0 <HAL_GPIO_Init+0xa4>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8000ebc:	2c03      	cmp	r4, #3
 8000ebe:	d1da      	bne.n	8000e76 <HAL_GPIO_Init+0x5a>
      temp = GPIOx->MODER;
 8000ec0:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000ec2:	fa04 f408 	lsl.w	r4, r4, r8
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000ec6:	403e      	ands	r6, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000ec8:	4326      	orrs	r6, r4
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8000eca:	f415 3f40 	tst.w	r5, #196608	; 0x30000
      GPIOx->MODER = temp;
 8000ece:	6006      	str	r6, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8000ed0:	d06b      	beq.n	8000faa <HAL_GPIO_Init+0x18e>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000ed2:	f04f 0a00 	mov.w	sl, #0
 8000ed6:	f8cd a004 	str.w	sl, [sp, #4]
 8000eda:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000ede:	4c40      	ldr	r4, [pc, #256]	; (8000fe0 <HAL_GPIO_Init+0x1c4>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000ee0:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 8000ee4:	f8c9 6044 	str.w	r6, [r9, #68]	; 0x44
 8000ee8:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
 8000eec:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8000ef0:	9601      	str	r6, [sp, #4]
 8000ef2:	9e01      	ldr	r6, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8000ef4:	f023 0603 	bic.w	r6, r3, #3
 8000ef8:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8000efc:	f506 369c 	add.w	r6, r6, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000f00:	f003 0e03 	and.w	lr, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8000f04:	f8d6 8008 	ldr.w	r8, [r6, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000f08:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8000f0c:	270f      	movs	r7, #15
 8000f0e:	fa07 f70e 	lsl.w	r7, r7, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000f12:	42a0      	cmp	r0, r4
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000f14:	ea28 0707 	bic.w	r7, r8, r7
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000f18:	d04e      	beq.n	8000fb8 <HAL_GPIO_Init+0x19c>
 8000f1a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f1e:	42a0      	cmp	r0, r4
 8000f20:	d04c      	beq.n	8000fbc <HAL_GPIO_Init+0x1a0>
 8000f22:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f26:	42a0      	cmp	r0, r4
 8000f28:	d04a      	beq.n	8000fc0 <HAL_GPIO_Init+0x1a4>
 8000f2a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f2e:	42a0      	cmp	r0, r4
 8000f30:	d048      	beq.n	8000fc4 <HAL_GPIO_Init+0x1a8>
 8000f32:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f36:	42a0      	cmp	r0, r4
 8000f38:	d046      	beq.n	8000fc8 <HAL_GPIO_Init+0x1ac>
 8000f3a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f3e:	42a0      	cmp	r0, r4
 8000f40:	d044      	beq.n	8000fcc <HAL_GPIO_Init+0x1b0>
 8000f42:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f46:	42a0      	cmp	r0, r4
 8000f48:	d042      	beq.n	8000fd0 <HAL_GPIO_Init+0x1b4>
 8000f4a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f4e:	42a0      	cmp	r0, r4
 8000f50:	d040      	beq.n	8000fd4 <HAL_GPIO_Init+0x1b8>
 8000f52:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f56:	42a0      	cmp	r0, r4
 8000f58:	d03e      	beq.n	8000fd8 <HAL_GPIO_Init+0x1bc>
 8000f5a:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000f5e:	42a0      	cmp	r0, r4
 8000f60:	bf0c      	ite	eq
 8000f62:	2409      	moveq	r4, #9
 8000f64:	240a      	movne	r4, #10
 8000f66:	fa04 f40e 	lsl.w	r4, r4, lr
 8000f6a:	433c      	orrs	r4, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000f6c:	60b4      	str	r4, [r6, #8]
        temp = EXTI->RTSR;
 8000f6e:	6894      	ldr	r4, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
 8000f70:	ea6f 060c 	mvn.w	r6, ip
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8000f74:	02ef      	lsls	r7, r5, #11
        temp &= ~((uint32_t)iocurrent);
 8000f76:	bf54      	ite	pl
 8000f78:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 8000f7a:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->RTSR = temp;
 8000f7e:	6094      	str	r4, [r2, #8]

        temp = EXTI->FTSR;
 8000f80:	68d4      	ldr	r4, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8000f82:	02af      	lsls	r7, r5, #10
        temp &= ~((uint32_t)iocurrent);
 8000f84:	bf54      	ite	pl
 8000f86:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 8000f88:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->FTSR = temp;
 8000f8c:	60d4      	str	r4, [r2, #12]

        temp = EXTI->EMR;
 8000f8e:	6854      	ldr	r4, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8000f90:	03af      	lsls	r7, r5, #14
        temp &= ~((uint32_t)iocurrent);
 8000f92:	bf54      	ite	pl
 8000f94:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 8000f96:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->EMR = temp;
 8000f9a:	6054      	str	r4, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000f9c:	6814      	ldr	r4, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8000f9e:	03ed      	lsls	r5, r5, #15
        temp &= ~((uint32_t)iocurrent);
 8000fa0:	bf54      	ite	pl
 8000fa2:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 8000fa4:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->IMR = temp;
 8000fa8:	6014      	str	r4, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000faa:	3301      	adds	r3, #1
 8000fac:	2b10      	cmp	r3, #16
 8000fae:	f47f af3b 	bne.w	8000e28 <HAL_GPIO_Init+0xc>
      }
    }
  }
}
 8000fb2:	b003      	add	sp, #12
 8000fb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000fb8:	4654      	mov	r4, sl
 8000fba:	e7d4      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fbc:	2401      	movs	r4, #1
 8000fbe:	e7d2      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fc0:	2402      	movs	r4, #2
 8000fc2:	e7d0      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fc4:	2403      	movs	r4, #3
 8000fc6:	e7ce      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fc8:	2404      	movs	r4, #4
 8000fca:	e7cc      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fcc:	2405      	movs	r4, #5
 8000fce:	e7ca      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fd0:	2406      	movs	r4, #6
 8000fd2:	e7c8      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fd4:	2407      	movs	r4, #7
 8000fd6:	e7c6      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fd8:	2408      	movs	r4, #8
 8000fda:	e7c4      	b.n	8000f66 <HAL_GPIO_Init+0x14a>
 8000fdc:	40013c00 	.word	0x40013c00
 8000fe0:	40020000 	.word	0x40020000
 8000fe4:	40023800 	.word	0x40023800

08000fe8 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 8000fe8:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8000fea:	ea01 0203 	and.w	r2, r1, r3
 8000fee:	ea21 0103 	bic.w	r1, r1, r3
 8000ff2:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8000ff6:	6181      	str	r1, [r0, #24]
}
 8000ff8:	4770      	bx	lr
	...

08000ffc <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 8000ffc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t tickstart = 0U;

  __HAL_RCC_PWR_CLK_ENABLE();
 8000ffe:	2300      	movs	r3, #0
 8001000:	9301      	str	r3, [sp, #4]
 8001002:	4b18      	ldr	r3, [pc, #96]	; (8001064 <HAL_PWREx_EnableOverDrive+0x68>)
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001004:	4d18      	ldr	r5, [pc, #96]	; (8001068 <HAL_PWREx_EnableOverDrive+0x6c>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8001006:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001008:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800100c:	641a      	str	r2, [r3, #64]	; 0x40
 800100e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001010:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001014:	9301      	str	r3, [sp, #4]
 8001016:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 8001018:	4b14      	ldr	r3, [pc, #80]	; (800106c <HAL_PWREx_EnableOverDrive+0x70>)
 800101a:	2201      	movs	r2, #1
 800101c:	641a      	str	r2, [r3, #64]	; 0x40
  tickstart = HAL_GetTick();
 800101e:	f7ff fc99 	bl	8000954 <HAL_GetTick>
 8001022:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001024:	686b      	ldr	r3, [r5, #4]
 8001026:	03da      	lsls	r2, r3, #15
 8001028:	d50b      	bpl.n	8001042 <HAL_PWREx_EnableOverDrive+0x46>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800102a:	4b10      	ldr	r3, [pc, #64]	; (800106c <HAL_PWREx_EnableOverDrive+0x70>)

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800102c:	4d0e      	ldr	r5, [pc, #56]	; (8001068 <HAL_PWREx_EnableOverDrive+0x6c>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800102e:	2201      	movs	r2, #1
 8001030:	645a      	str	r2, [r3, #68]	; 0x44
  tickstart = HAL_GetTick();
 8001032:	f7ff fc8f 	bl	8000954 <HAL_GetTick>
 8001036:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001038:	686b      	ldr	r3, [r5, #4]
 800103a:	039b      	lsls	r3, r3, #14
 800103c:	d50a      	bpl.n	8001054 <HAL_PWREx_EnableOverDrive+0x58>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 800103e:	2000      	movs	r0, #0
 8001040:	e006      	b.n	8001050 <HAL_PWREx_EnableOverDrive+0x54>
    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001042:	f7ff fc87 	bl	8000954 <HAL_GetTick>
 8001046:	1b00      	subs	r0, r0, r4
 8001048:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800104c:	d9ea      	bls.n	8001024 <HAL_PWREx_EnableOverDrive+0x28>
      return HAL_TIMEOUT;
 800104e:	2003      	movs	r0, #3
}
 8001050:	b003      	add	sp, #12
 8001052:	bd30      	pop	{r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001054:	f7ff fc7e 	bl	8000954 <HAL_GetTick>
 8001058:	1b00      	subs	r0, r0, r4
 800105a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800105e:	d9eb      	bls.n	8001038 <HAL_PWREx_EnableOverDrive+0x3c>
 8001060:	e7f5      	b.n	800104e <HAL_PWREx_EnableOverDrive+0x52>
 8001062:	bf00      	nop
 8001064:	40023800 	.word	0x40023800
 8001068:	40007000 	.word	0x40007000
 800106c:	420e0000 	.word	0x420e0000

08001070 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001070:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8001074:	4604      	mov	r4, r0
 8001076:	b340      	cbz	r0, 80010ca <HAL_RCC_OscConfig+0x5a>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001078:	6803      	ldr	r3, [r0, #0]
 800107a:	07dd      	lsls	r5, r3, #31
 800107c:	d410      	bmi.n	80010a0 <HAL_RCC_OscConfig+0x30>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800107e:	6823      	ldr	r3, [r4, #0]
 8001080:	0798      	lsls	r0, r3, #30
 8001082:	d45e      	bmi.n	8001142 <HAL_RCC_OscConfig+0xd2>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001084:	6823      	ldr	r3, [r4, #0]
 8001086:	071a      	lsls	r2, r3, #28
 8001088:	f100 80a0 	bmi.w	80011cc <HAL_RCC_OscConfig+0x15c>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800108c:	6823      	ldr	r3, [r4, #0]
 800108e:	075b      	lsls	r3, r3, #29
 8001090:	f100 80c0 	bmi.w	8001214 <HAL_RCC_OscConfig+0x1a4>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001094:	69a0      	ldr	r0, [r4, #24]
 8001096:	2800      	cmp	r0, #0
 8001098:	f040 8128 	bne.w	80012ec <HAL_RCC_OscConfig+0x27c>
          return HAL_ERROR;
        }
      }
    }
  }
  return HAL_OK;
 800109c:	2000      	movs	r0, #0
 800109e:	e02b      	b.n	80010f8 <HAL_RCC_OscConfig+0x88>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80010a0:	4b8f      	ldr	r3, [pc, #572]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 80010a2:	689a      	ldr	r2, [r3, #8]
 80010a4:	f002 020c 	and.w	r2, r2, #12
 80010a8:	2a04      	cmp	r2, #4
 80010aa:	d007      	beq.n	80010bc <HAL_RCC_OscConfig+0x4c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80010ac:	689a      	ldr	r2, [r3, #8]
 80010ae:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80010b2:	2a08      	cmp	r2, #8
 80010b4:	d10b      	bne.n	80010ce <HAL_RCC_OscConfig+0x5e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80010b6:	685a      	ldr	r2, [r3, #4]
 80010b8:	0251      	lsls	r1, r2, #9
 80010ba:	d508      	bpl.n	80010ce <HAL_RCC_OscConfig+0x5e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80010bc:	4b88      	ldr	r3, [pc, #544]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 80010be:	681b      	ldr	r3, [r3, #0]
 80010c0:	039a      	lsls	r2, r3, #14
 80010c2:	d5dc      	bpl.n	800107e <HAL_RCC_OscConfig+0xe>
 80010c4:	6863      	ldr	r3, [r4, #4]
 80010c6:	2b00      	cmp	r3, #0
 80010c8:	d1d9      	bne.n	800107e <HAL_RCC_OscConfig+0xe>
          return HAL_ERROR;
 80010ca:	2001      	movs	r0, #1
 80010cc:	e014      	b.n	80010f8 <HAL_RCC_OscConfig+0x88>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80010ce:	6862      	ldr	r2, [r4, #4]
 80010d0:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80010d4:	d113      	bne.n	80010fe <HAL_RCC_OscConfig+0x8e>
 80010d6:	681a      	ldr	r2, [r3, #0]
 80010d8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80010dc:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80010de:	f7ff fc39 	bl	8000954 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80010e2:	4e7f      	ldr	r6, [pc, #508]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
        tickstart = HAL_GetTick();
 80010e4:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80010e6:	6833      	ldr	r3, [r6, #0]
 80010e8:	039b      	lsls	r3, r3, #14
 80010ea:	d4c8      	bmi.n	800107e <HAL_RCC_OscConfig+0xe>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80010ec:	f7ff fc32 	bl	8000954 <HAL_GetTick>
 80010f0:	1b40      	subs	r0, r0, r5
 80010f2:	2864      	cmp	r0, #100	; 0x64
 80010f4:	d9f7      	bls.n	80010e6 <HAL_RCC_OscConfig+0x76>
            return HAL_TIMEOUT;
 80010f6:	2003      	movs	r0, #3
}
 80010f8:	b002      	add	sp, #8
 80010fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80010fe:	4d78      	ldr	r5, [pc, #480]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 8001100:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
 8001104:	682b      	ldr	r3, [r5, #0]
 8001106:	d107      	bne.n	8001118 <HAL_RCC_OscConfig+0xa8>
 8001108:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800110c:	602b      	str	r3, [r5, #0]
 800110e:	682b      	ldr	r3, [r5, #0]
 8001110:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001114:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001116:	e7e2      	b.n	80010de <HAL_RCC_OscConfig+0x6e>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001118:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800111c:	602b      	str	r3, [r5, #0]
 800111e:	682b      	ldr	r3, [r5, #0]
 8001120:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001124:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001126:	2a00      	cmp	r2, #0
 8001128:	d1d9      	bne.n	80010de <HAL_RCC_OscConfig+0x6e>
        tickstart = HAL_GetTick();
 800112a:	f7ff fc13 	bl	8000954 <HAL_GetTick>
 800112e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001130:	682b      	ldr	r3, [r5, #0]
 8001132:	039f      	lsls	r7, r3, #14
 8001134:	d5a3      	bpl.n	800107e <HAL_RCC_OscConfig+0xe>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001136:	f7ff fc0d 	bl	8000954 <HAL_GetTick>
 800113a:	1b80      	subs	r0, r0, r6
 800113c:	2864      	cmp	r0, #100	; 0x64
 800113e:	d9f7      	bls.n	8001130 <HAL_RCC_OscConfig+0xc0>
 8001140:	e7d9      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001142:	4b67      	ldr	r3, [pc, #412]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 8001144:	689a      	ldr	r2, [r3, #8]
 8001146:	f012 0f0c 	tst.w	r2, #12
 800114a:	d007      	beq.n	800115c <HAL_RCC_OscConfig+0xec>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800114c:	689a      	ldr	r2, [r3, #8]
 800114e:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001152:	2a08      	cmp	r2, #8
 8001154:	d111      	bne.n	800117a <HAL_RCC_OscConfig+0x10a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001156:	685b      	ldr	r3, [r3, #4]
 8001158:	025e      	lsls	r6, r3, #9
 800115a:	d40e      	bmi.n	800117a <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800115c:	4a60      	ldr	r2, [pc, #384]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 800115e:	6813      	ldr	r3, [r2, #0]
 8001160:	079d      	lsls	r5, r3, #30
 8001162:	d502      	bpl.n	800116a <HAL_RCC_OscConfig+0xfa>
 8001164:	68e3      	ldr	r3, [r4, #12]
 8001166:	2b01      	cmp	r3, #1
 8001168:	d1af      	bne.n	80010ca <HAL_RCC_OscConfig+0x5a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800116a:	6813      	ldr	r3, [r2, #0]
 800116c:	6921      	ldr	r1, [r4, #16]
 800116e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001172:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001176:	6013      	str	r3, [r2, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001178:	e784      	b.n	8001084 <HAL_RCC_OscConfig+0x14>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800117a:	68e2      	ldr	r2, [r4, #12]
 800117c:	4b59      	ldr	r3, [pc, #356]	; (80012e4 <HAL_RCC_OscConfig+0x274>)
 800117e:	b1b2      	cbz	r2, 80011ae <HAL_RCC_OscConfig+0x13e>
        __HAL_RCC_HSI_ENABLE();
 8001180:	2201      	movs	r2, #1
 8001182:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001184:	f7ff fbe6 	bl	8000954 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001188:	4d55      	ldr	r5, [pc, #340]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
        tickstart = HAL_GetTick();
 800118a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800118c:	682b      	ldr	r3, [r5, #0]
 800118e:	0798      	lsls	r0, r3, #30
 8001190:	d507      	bpl.n	80011a2 <HAL_RCC_OscConfig+0x132>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001192:	682b      	ldr	r3, [r5, #0]
 8001194:	6922      	ldr	r2, [r4, #16]
 8001196:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800119a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800119e:	602b      	str	r3, [r5, #0]
 80011a0:	e770      	b.n	8001084 <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80011a2:	f7ff fbd7 	bl	8000954 <HAL_GetTick>
 80011a6:	1b80      	subs	r0, r0, r6
 80011a8:	2802      	cmp	r0, #2
 80011aa:	d9ef      	bls.n	800118c <HAL_RCC_OscConfig+0x11c>
 80011ac:	e7a3      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
        __HAL_RCC_HSI_DISABLE();
 80011ae:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80011b0:	f7ff fbd0 	bl	8000954 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80011b4:	4e4a      	ldr	r6, [pc, #296]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
        tickstart = HAL_GetTick();
 80011b6:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80011b8:	6833      	ldr	r3, [r6, #0]
 80011ba:	0799      	lsls	r1, r3, #30
 80011bc:	f57f af62 	bpl.w	8001084 <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80011c0:	f7ff fbc8 	bl	8000954 <HAL_GetTick>
 80011c4:	1b40      	subs	r0, r0, r5
 80011c6:	2802      	cmp	r0, #2
 80011c8:	d9f6      	bls.n	80011b8 <HAL_RCC_OscConfig+0x148>
 80011ca:	e794      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80011cc:	6962      	ldr	r2, [r4, #20]
 80011ce:	4b45      	ldr	r3, [pc, #276]	; (80012e4 <HAL_RCC_OscConfig+0x274>)
 80011d0:	b182      	cbz	r2, 80011f4 <HAL_RCC_OscConfig+0x184>
      __HAL_RCC_LSI_ENABLE();
 80011d2:	2201      	movs	r2, #1
 80011d4:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
      tickstart = HAL_GetTick();
 80011d8:	f7ff fbbc 	bl	8000954 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80011dc:	4e40      	ldr	r6, [pc, #256]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
      tickstart = HAL_GetTick();
 80011de:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80011e0:	6f73      	ldr	r3, [r6, #116]	; 0x74
 80011e2:	079f      	lsls	r7, r3, #30
 80011e4:	f53f af52 	bmi.w	800108c <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80011e8:	f7ff fbb4 	bl	8000954 <HAL_GetTick>
 80011ec:	1b40      	subs	r0, r0, r5
 80011ee:	2802      	cmp	r0, #2
 80011f0:	d9f6      	bls.n	80011e0 <HAL_RCC_OscConfig+0x170>
 80011f2:	e780      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
      __HAL_RCC_LSI_DISABLE();
 80011f4:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
      tickstart = HAL_GetTick();
 80011f8:	f7ff fbac 	bl	8000954 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80011fc:	4e38      	ldr	r6, [pc, #224]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
      tickstart = HAL_GetTick();
 80011fe:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001200:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8001202:	0798      	lsls	r0, r3, #30
 8001204:	f57f af42 	bpl.w	800108c <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001208:	f7ff fba4 	bl	8000954 <HAL_GetTick>
 800120c:	1b40      	subs	r0, r0, r5
 800120e:	2802      	cmp	r0, #2
 8001210:	d9f6      	bls.n	8001200 <HAL_RCC_OscConfig+0x190>
 8001212:	e770      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001214:	4b32      	ldr	r3, [pc, #200]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 8001216:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001218:	f012 5280 	ands.w	r2, r2, #268435456	; 0x10000000
 800121c:	d128      	bne.n	8001270 <HAL_RCC_OscConfig+0x200>
      __HAL_RCC_PWR_CLK_ENABLE();
 800121e:	9201      	str	r2, [sp, #4]
 8001220:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001222:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001226:	641a      	str	r2, [r3, #64]	; 0x40
 8001228:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800122a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800122e:	9301      	str	r3, [sp, #4]
 8001230:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001232:	2701      	movs	r7, #1
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001234:	4d2c      	ldr	r5, [pc, #176]	; (80012e8 <HAL_RCC_OscConfig+0x278>)
 8001236:	682b      	ldr	r3, [r5, #0]
 8001238:	05d9      	lsls	r1, r3, #23
 800123a:	d51b      	bpl.n	8001274 <HAL_RCC_OscConfig+0x204>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800123c:	68a3      	ldr	r3, [r4, #8]
 800123e:	4d28      	ldr	r5, [pc, #160]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 8001240:	2b01      	cmp	r3, #1
 8001242:	d127      	bne.n	8001294 <HAL_RCC_OscConfig+0x224>
 8001244:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001246:	f043 0301 	orr.w	r3, r3, #1
 800124a:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 800124c:	f7ff fb82 	bl	8000954 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001250:	4e23      	ldr	r6, [pc, #140]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
      tickstart = HAL_GetTick();
 8001252:	4605      	mov	r5, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001254:	f241 3888 	movw	r8, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001258:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800125a:	079b      	lsls	r3, r3, #30
 800125c:	d539      	bpl.n	80012d2 <HAL_RCC_OscConfig+0x262>
    if(pwrclkchanged == SET)
 800125e:	2f00      	cmp	r7, #0
 8001260:	f43f af18 	beq.w	8001094 <HAL_RCC_OscConfig+0x24>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001264:	4a1e      	ldr	r2, [pc, #120]	; (80012e0 <HAL_RCC_OscConfig+0x270>)
 8001266:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001268:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800126c:	6413      	str	r3, [r2, #64]	; 0x40
 800126e:	e711      	b.n	8001094 <HAL_RCC_OscConfig+0x24>
    FlagStatus       pwrclkchanged = RESET;
 8001270:	2700      	movs	r7, #0
 8001272:	e7df      	b.n	8001234 <HAL_RCC_OscConfig+0x1c4>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001274:	682b      	ldr	r3, [r5, #0]
 8001276:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800127a:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800127c:	f7ff fb6a 	bl	8000954 <HAL_GetTick>
 8001280:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001282:	682b      	ldr	r3, [r5, #0]
 8001284:	05da      	lsls	r2, r3, #23
 8001286:	d4d9      	bmi.n	800123c <HAL_RCC_OscConfig+0x1cc>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001288:	f7ff fb64 	bl	8000954 <HAL_GetTick>
 800128c:	1b80      	subs	r0, r0, r6
 800128e:	2802      	cmp	r0, #2
 8001290:	d9f7      	bls.n	8001282 <HAL_RCC_OscConfig+0x212>
 8001292:	e730      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001294:	2b05      	cmp	r3, #5
 8001296:	d104      	bne.n	80012a2 <HAL_RCC_OscConfig+0x232>
 8001298:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800129a:	f043 0304 	orr.w	r3, r3, #4
 800129e:	672b      	str	r3, [r5, #112]	; 0x70
 80012a0:	e7d0      	b.n	8001244 <HAL_RCC_OscConfig+0x1d4>
 80012a2:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 80012a4:	f022 0201 	bic.w	r2, r2, #1
 80012a8:	672a      	str	r2, [r5, #112]	; 0x70
 80012aa:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 80012ac:	f022 0204 	bic.w	r2, r2, #4
 80012b0:	672a      	str	r2, [r5, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80012b2:	2b00      	cmp	r3, #0
 80012b4:	d1ca      	bne.n	800124c <HAL_RCC_OscConfig+0x1dc>
      tickstart = HAL_GetTick();
 80012b6:	f7ff fb4d 	bl	8000954 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80012ba:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80012be:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80012c0:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80012c2:	0798      	lsls	r0, r3, #30
 80012c4:	d5cb      	bpl.n	800125e <HAL_RCC_OscConfig+0x1ee>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80012c6:	f7ff fb45 	bl	8000954 <HAL_GetTick>
 80012ca:	1b80      	subs	r0, r0, r6
 80012cc:	4540      	cmp	r0, r8
 80012ce:	d9f7      	bls.n	80012c0 <HAL_RCC_OscConfig+0x250>
 80012d0:	e711      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80012d2:	f7ff fb3f 	bl	8000954 <HAL_GetTick>
 80012d6:	1b40      	subs	r0, r0, r5
 80012d8:	4540      	cmp	r0, r8
 80012da:	d9bd      	bls.n	8001258 <HAL_RCC_OscConfig+0x1e8>
 80012dc:	e70b      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
 80012de:	bf00      	nop
 80012e0:	40023800 	.word	0x40023800
 80012e4:	42470000 	.word	0x42470000
 80012e8:	40007000 	.word	0x40007000
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80012ec:	4d36      	ldr	r5, [pc, #216]	; (80013c8 <HAL_RCC_OscConfig+0x358>)
 80012ee:	68ab      	ldr	r3, [r5, #8]
 80012f0:	f003 030c 	and.w	r3, r3, #12
 80012f4:	2b08      	cmp	r3, #8
 80012f6:	d03d      	beq.n	8001374 <HAL_RCC_OscConfig+0x304>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80012f8:	4b34      	ldr	r3, [pc, #208]	; (80013cc <HAL_RCC_OscConfig+0x35c>)
 80012fa:	2200      	movs	r2, #0
 80012fc:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 80012fe:	661a      	str	r2, [r3, #96]	; 0x60
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001300:	d12b      	bne.n	800135a <HAL_RCC_OscConfig+0x2ea>
        tickstart = HAL_GetTick();
 8001302:	f7ff fb27 	bl	8000954 <HAL_GetTick>
 8001306:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001308:	682b      	ldr	r3, [r5, #0]
 800130a:	0199      	lsls	r1, r3, #6
 800130c:	d41f      	bmi.n	800134e <HAL_RCC_OscConfig+0x2de>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800130e:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 8001312:	4313      	orrs	r3, r2
 8001314:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001316:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 800131a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800131c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001320:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001322:	0852      	lsrs	r2, r2, #1
 8001324:	3a01      	subs	r2, #1
 8001326:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800132a:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 800132c:	4b27      	ldr	r3, [pc, #156]	; (80013cc <HAL_RCC_OscConfig+0x35c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800132e:	4d26      	ldr	r5, [pc, #152]	; (80013c8 <HAL_RCC_OscConfig+0x358>)
        __HAL_RCC_PLL_ENABLE();
 8001330:	2201      	movs	r2, #1
 8001332:	661a      	str	r2, [r3, #96]	; 0x60
        tickstart = HAL_GetTick();
 8001334:	f7ff fb0e 	bl	8000954 <HAL_GetTick>
 8001338:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800133a:	682b      	ldr	r3, [r5, #0]
 800133c:	019a      	lsls	r2, r3, #6
 800133e:	f53f aead 	bmi.w	800109c <HAL_RCC_OscConfig+0x2c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001342:	f7ff fb07 	bl	8000954 <HAL_GetTick>
 8001346:	1b00      	subs	r0, r0, r4
 8001348:	2802      	cmp	r0, #2
 800134a:	d9f6      	bls.n	800133a <HAL_RCC_OscConfig+0x2ca>
 800134c:	e6d3      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800134e:	f7ff fb01 	bl	8000954 <HAL_GetTick>
 8001352:	1b80      	subs	r0, r0, r6
 8001354:	2802      	cmp	r0, #2
 8001356:	d9d7      	bls.n	8001308 <HAL_RCC_OscConfig+0x298>
 8001358:	e6cd      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
        tickstart = HAL_GetTick();
 800135a:	f7ff fafb 	bl	8000954 <HAL_GetTick>
 800135e:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001360:	682b      	ldr	r3, [r5, #0]
 8001362:	019b      	lsls	r3, r3, #6
 8001364:	f57f ae9a 	bpl.w	800109c <HAL_RCC_OscConfig+0x2c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001368:	f7ff faf4 	bl	8000954 <HAL_GetTick>
 800136c:	1b00      	subs	r0, r0, r4
 800136e:	2802      	cmp	r0, #2
 8001370:	d9f6      	bls.n	8001360 <HAL_RCC_OscConfig+0x2f0>
 8001372:	e6c0      	b.n	80010f6 <HAL_RCC_OscConfig+0x86>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8001374:	2801      	cmp	r0, #1
 8001376:	f43f aebf 	beq.w	80010f8 <HAL_RCC_OscConfig+0x88>
        pll_config = RCC->PLLCFGR;
 800137a:	686b      	ldr	r3, [r5, #4]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800137c:	69e2      	ldr	r2, [r4, #28]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800137e:	f403 0180 	and.w	r1, r3, #4194304	; 0x400000
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8001382:	4291      	cmp	r1, r2
 8001384:	f47f aea1 	bne.w	80010ca <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001388:	6a21      	ldr	r1, [r4, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800138a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800138e:	428a      	cmp	r2, r1
 8001390:	f47f ae9b 	bne.w	80010ca <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8001394:	6a61      	ldr	r1, [r4, #36]	; 0x24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8001396:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 800139a:	401a      	ands	r2, r3
 800139c:	ebb2 1f81 	cmp.w	r2, r1, lsl #6
 80013a0:	f47f ae93 	bne.w	80010ca <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80013a4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80013a6:	0852      	lsrs	r2, r2, #1
 80013a8:	f403 3140 	and.w	r1, r3, #196608	; 0x30000
 80013ac:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80013ae:	ebb1 4f02 	cmp.w	r1, r2, lsl #16
 80013b2:	f47f ae8a 	bne.w	80010ca <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 80013b6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80013b8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80013bc:	ebb3 6f02 	cmp.w	r3, r2, lsl #24
 80013c0:	f43f ae6c 	beq.w	800109c <HAL_RCC_OscConfig+0x2c>
 80013c4:	e681      	b.n	80010ca <HAL_RCC_OscConfig+0x5a>
 80013c6:	bf00      	nop
 80013c8:	40023800 	.word	0x40023800
 80013cc:	42470000 	.word	0x42470000

080013d0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80013d0:	4913      	ldr	r1, [pc, #76]	; (8001420 <HAL_RCC_GetSysClockFreq+0x50>)
{
 80013d2:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80013d4:	688b      	ldr	r3, [r1, #8]
 80013d6:	f003 030c 	and.w	r3, r3, #12
 80013da:	2b04      	cmp	r3, #4
 80013dc:	d01c      	beq.n	8001418 <HAL_RCC_GetSysClockFreq+0x48>
 80013de:	2b08      	cmp	r3, #8
 80013e0:	d11c      	bne.n	800141c <HAL_RCC_GetSysClockFreq+0x4c>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80013e2:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80013e4:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80013e6:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80013e8:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80013ec:	bf14      	ite	ne
 80013ee:	480d      	ldrne	r0, [pc, #52]	; (8001424 <HAL_RCC_GetSysClockFreq+0x54>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80013f0:	480d      	ldreq	r0, [pc, #52]	; (8001428 <HAL_RCC_GetSysClockFreq+0x58>)
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80013f2:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80013f6:	bf18      	it	ne
 80013f8:	2300      	movne	r3, #0
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80013fa:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80013fe:	fba1 0100 	umull	r0, r1, r1, r0
 8001402:	f7fe fef3 	bl	80001ec <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8001406:	4b06      	ldr	r3, [pc, #24]	; (8001420 <HAL_RCC_GetSysClockFreq+0x50>)
 8001408:	685b      	ldr	r3, [r3, #4]
 800140a:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800140e:	3301      	adds	r3, #1
 8001410:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 8001412:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001416:	bd08      	pop	{r3, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001418:	4802      	ldr	r0, [pc, #8]	; (8001424 <HAL_RCC_GetSysClockFreq+0x54>)
 800141a:	e7fc      	b.n	8001416 <HAL_RCC_GetSysClockFreq+0x46>
      sysclockfreq = HSI_VALUE;
 800141c:	4802      	ldr	r0, [pc, #8]	; (8001428 <HAL_RCC_GetSysClockFreq+0x58>)
  return sysclockfreq;
 800141e:	e7fa      	b.n	8001416 <HAL_RCC_GetSysClockFreq+0x46>
 8001420:	40023800 	.word	0x40023800
 8001424:	017d7840 	.word	0x017d7840
 8001428:	00f42400 	.word	0x00f42400

0800142c <HAL_RCC_ClockConfig>:
{
 800142c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001430:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
 8001432:	4604      	mov	r4, r0
 8001434:	b910      	cbnz	r0, 800143c <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8001436:	2001      	movs	r0, #1
}
 8001438:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800143c:	4b44      	ldr	r3, [pc, #272]	; (8001550 <HAL_RCC_ClockConfig+0x124>)
 800143e:	681a      	ldr	r2, [r3, #0]
 8001440:	f002 020f 	and.w	r2, r2, #15
 8001444:	428a      	cmp	r2, r1
 8001446:	d328      	bcc.n	800149a <HAL_RCC_ClockConfig+0x6e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001448:	6822      	ldr	r2, [r4, #0]
 800144a:	0797      	lsls	r7, r2, #30
 800144c:	d42d      	bmi.n	80014aa <HAL_RCC_ClockConfig+0x7e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800144e:	07d0      	lsls	r0, r2, #31
 8001450:	d441      	bmi.n	80014d6 <HAL_RCC_ClockConfig+0xaa>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8001452:	4b3f      	ldr	r3, [pc, #252]	; (8001550 <HAL_RCC_ClockConfig+0x124>)
 8001454:	681a      	ldr	r2, [r3, #0]
 8001456:	f002 020f 	and.w	r2, r2, #15
 800145a:	42aa      	cmp	r2, r5
 800145c:	d866      	bhi.n	800152c <HAL_RCC_ClockConfig+0x100>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800145e:	6822      	ldr	r2, [r4, #0]
 8001460:	0751      	lsls	r1, r2, #29
 8001462:	d46c      	bmi.n	800153e <HAL_RCC_ClockConfig+0x112>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001464:	0713      	lsls	r3, r2, #28
 8001466:	d507      	bpl.n	8001478 <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001468:	4a3a      	ldr	r2, [pc, #232]	; (8001554 <HAL_RCC_ClockConfig+0x128>)
 800146a:	6921      	ldr	r1, [r4, #16]
 800146c:	6893      	ldr	r3, [r2, #8]
 800146e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001472:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001476:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8001478:	f7ff ffaa 	bl	80013d0 <HAL_RCC_GetSysClockFreq>
 800147c:	4b35      	ldr	r3, [pc, #212]	; (8001554 <HAL_RCC_ClockConfig+0x128>)
 800147e:	4a36      	ldr	r2, [pc, #216]	; (8001558 <HAL_RCC_ClockConfig+0x12c>)
 8001480:	689b      	ldr	r3, [r3, #8]
 8001482:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001486:	5cd3      	ldrb	r3, [r2, r3]
 8001488:	40d8      	lsrs	r0, r3
 800148a:	4b34      	ldr	r3, [pc, #208]	; (800155c <HAL_RCC_ClockConfig+0x130>)
 800148c:	6018      	str	r0, [r3, #0]
  HAL_InitTick (uwTickPrio);
 800148e:	4b34      	ldr	r3, [pc, #208]	; (8001560 <HAL_RCC_ClockConfig+0x134>)
 8001490:	6818      	ldr	r0, [r3, #0]
 8001492:	f7ff fa17 	bl	80008c4 <HAL_InitTick>
  return HAL_OK;
 8001496:	2000      	movs	r0, #0
 8001498:	e7ce      	b.n	8001438 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800149a:	b2ca      	uxtb	r2, r1
 800149c:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800149e:	681b      	ldr	r3, [r3, #0]
 80014a0:	f003 030f 	and.w	r3, r3, #15
 80014a4:	428b      	cmp	r3, r1
 80014a6:	d1c6      	bne.n	8001436 <HAL_RCC_ClockConfig+0xa>
 80014a8:	e7ce      	b.n	8001448 <HAL_RCC_ClockConfig+0x1c>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80014aa:	4b2a      	ldr	r3, [pc, #168]	; (8001554 <HAL_RCC_ClockConfig+0x128>)
 80014ac:	f012 0f04 	tst.w	r2, #4
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80014b0:	bf1e      	ittt	ne
 80014b2:	6899      	ldrne	r1, [r3, #8]
 80014b4:	f441 51e0 	orrne.w	r1, r1, #7168	; 0x1c00
 80014b8:	6099      	strne	r1, [r3, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80014ba:	0716      	lsls	r6, r2, #28
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80014bc:	bf42      	ittt	mi
 80014be:	6899      	ldrmi	r1, [r3, #8]
 80014c0:	f441 4160 	orrmi.w	r1, r1, #57344	; 0xe000
 80014c4:	6099      	strmi	r1, [r3, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80014c6:	4923      	ldr	r1, [pc, #140]	; (8001554 <HAL_RCC_ClockConfig+0x128>)
 80014c8:	68a0      	ldr	r0, [r4, #8]
 80014ca:	688b      	ldr	r3, [r1, #8]
 80014cc:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80014d0:	4303      	orrs	r3, r0
 80014d2:	608b      	str	r3, [r1, #8]
 80014d4:	e7bb      	b.n	800144e <HAL_RCC_ClockConfig+0x22>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80014d6:	6862      	ldr	r2, [r4, #4]
 80014d8:	4b1e      	ldr	r3, [pc, #120]	; (8001554 <HAL_RCC_ClockConfig+0x128>)
 80014da:	2a01      	cmp	r2, #1
 80014dc:	d11c      	bne.n	8001518 <HAL_RCC_ClockConfig+0xec>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80014de:	681b      	ldr	r3, [r3, #0]
 80014e0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80014e4:	d0a7      	beq.n	8001436 <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80014e6:	4e1b      	ldr	r6, [pc, #108]	; (8001554 <HAL_RCC_ClockConfig+0x128>)
 80014e8:	68b3      	ldr	r3, [r6, #8]
 80014ea:	f023 0303 	bic.w	r3, r3, #3
 80014ee:	4313      	orrs	r3, r2
 80014f0:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80014f2:	f7ff fa2f 	bl	8000954 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80014f6:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80014fa:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80014fc:	68b3      	ldr	r3, [r6, #8]
 80014fe:	6862      	ldr	r2, [r4, #4]
 8001500:	f003 030c 	and.w	r3, r3, #12
 8001504:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001508:	d0a3      	beq.n	8001452 <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800150a:	f7ff fa23 	bl	8000954 <HAL_GetTick>
 800150e:	1bc0      	subs	r0, r0, r7
 8001510:	4540      	cmp	r0, r8
 8001512:	d9f3      	bls.n	80014fc <HAL_RCC_ClockConfig+0xd0>
        return HAL_TIMEOUT;
 8001514:	2003      	movs	r0, #3
 8001516:	e78f      	b.n	8001438 <HAL_RCC_ClockConfig+0xc>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8001518:	1e91      	subs	r1, r2, #2
 800151a:	2901      	cmp	r1, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800151c:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800151e:	d802      	bhi.n	8001526 <HAL_RCC_ClockConfig+0xfa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001520:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001524:	e7de      	b.n	80014e4 <HAL_RCC_ClockConfig+0xb8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001526:	f013 0f02 	tst.w	r3, #2
 800152a:	e7db      	b.n	80014e4 <HAL_RCC_ClockConfig+0xb8>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800152c:	b2ea      	uxtb	r2, r5
 800152e:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001530:	681b      	ldr	r3, [r3, #0]
 8001532:	f003 030f 	and.w	r3, r3, #15
 8001536:	42ab      	cmp	r3, r5
 8001538:	f47f af7d 	bne.w	8001436 <HAL_RCC_ClockConfig+0xa>
 800153c:	e78f      	b.n	800145e <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800153e:	4905      	ldr	r1, [pc, #20]	; (8001554 <HAL_RCC_ClockConfig+0x128>)
 8001540:	68e0      	ldr	r0, [r4, #12]
 8001542:	688b      	ldr	r3, [r1, #8]
 8001544:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8001548:	4303      	orrs	r3, r0
 800154a:	608b      	str	r3, [r1, #8]
 800154c:	e78a      	b.n	8001464 <HAL_RCC_ClockConfig+0x38>
 800154e:	bf00      	nop
 8001550:	40023c00 	.word	0x40023c00
 8001554:	40023800 	.word	0x40023800
 8001558:	08001e0c 	.word	0x08001e0c
 800155c:	20000048 	.word	0x20000048
 8001560:	20000050 	.word	0x20000050

08001564 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8001564:	4b04      	ldr	r3, [pc, #16]	; (8001578 <HAL_RCC_GetPCLK1Freq+0x14>)
 8001566:	4a05      	ldr	r2, [pc, #20]	; (800157c <HAL_RCC_GetPCLK1Freq+0x18>)
 8001568:	689b      	ldr	r3, [r3, #8]
 800156a:	f3c3 2382 	ubfx	r3, r3, #10, #3
 800156e:	5cd3      	ldrb	r3, [r2, r3]
 8001570:	4a03      	ldr	r2, [pc, #12]	; (8001580 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8001572:	6810      	ldr	r0, [r2, #0]
}
 8001574:	40d8      	lsrs	r0, r3
 8001576:	4770      	bx	lr
 8001578:	40023800 	.word	0x40023800
 800157c:	08001e1c 	.word	0x08001e1c
 8001580:	20000048 	.word	0x20000048

08001584 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8001584:	4b04      	ldr	r3, [pc, #16]	; (8001598 <HAL_RCC_GetPCLK2Freq+0x14>)
 8001586:	4a05      	ldr	r2, [pc, #20]	; (800159c <HAL_RCC_GetPCLK2Freq+0x18>)
 8001588:	689b      	ldr	r3, [r3, #8]
 800158a:	f3c3 3342 	ubfx	r3, r3, #13, #3
 800158e:	5cd3      	ldrb	r3, [r2, r3]
 8001590:	4a03      	ldr	r2, [pc, #12]	; (80015a0 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8001592:	6810      	ldr	r0, [r2, #0]
}
 8001594:	40d8      	lsrs	r0, r3
 8001596:	4770      	bx	lr
 8001598:	40023800 	.word	0x40023800
 800159c:	08001e1c 	.word	0x08001e1c
 80015a0:	20000048 	.word	0x20000048

080015a4 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80015a4:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80015a6:	f102 030c 	add.w	r3, r2, #12
 80015aa:	e853 3f00 	ldrex	r3, [r3]
 80015ae:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80015b2:	320c      	adds	r2, #12
 80015b4:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80015b8:	6802      	ldr	r2, [r0, #0]
 80015ba:	2900      	cmp	r1, #0
 80015bc:	d1f2      	bne.n	80015a4 <UART_EndRxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80015be:	f102 0314 	add.w	r3, r2, #20
 80015c2:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80015c6:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80015ca:	f102 0c14 	add.w	ip, r2, #20
 80015ce:	e84c 3100 	strex	r1, r3, [ip]
 80015d2:	2900      	cmp	r1, #0
 80015d4:	d1f3      	bne.n	80015be <UART_EndRxTransfer+0x1a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80015d6:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80015d8:	2b01      	cmp	r3, #1
 80015da:	d10b      	bne.n	80015f4 <UART_EndRxTransfer+0x50>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80015dc:	f102 030c 	add.w	r3, r2, #12
 80015e0:	e853 3f00 	ldrex	r3, [r3]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80015e4:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80015e8:	f102 0c0c 	add.w	ip, r2, #12
 80015ec:	e84c 3100 	strex	r1, r3, [ip]
 80015f0:	2900      	cmp	r1, #0
 80015f2:	d1f3      	bne.n	80015dc <UART_EndRxTransfer+0x38>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80015f4:	2320      	movs	r3, #32
 80015f6:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80015fa:	2300      	movs	r3, #0
 80015fc:	6303      	str	r3, [r0, #48]	; 0x30
}
 80015fe:	4770      	bx	lr

08001600 <UART_SetConfig>:
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001600:	6802      	ldr	r2, [r0, #0]
 8001602:	68c1      	ldr	r1, [r0, #12]
 8001604:	6913      	ldr	r3, [r2, #16]
 8001606:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800160a:	430b      	orrs	r3, r1
{
 800160c:	b570      	push	{r4, r5, r6, lr}
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800160e:	6113      	str	r3, [r2, #16]
{
 8001610:	4605      	mov	r5, r0
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001612:	6883      	ldr	r3, [r0, #8]
 8001614:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1,
 8001616:	68d1      	ldr	r1, [r2, #12]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001618:	4303      	orrs	r3, r0
 800161a:	6968      	ldr	r0, [r5, #20]
 800161c:	4303      	orrs	r3, r0
 800161e:	69e8      	ldr	r0, [r5, #28]
  MODIFY_REG(huart->Instance->CR1,
 8001620:	f421 4116 	bic.w	r1, r1, #38400	; 0x9600
 8001624:	f021 010c 	bic.w	r1, r1, #12
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001628:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1,
 800162a:	430b      	orrs	r3, r1
 800162c:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 800162e:	6953      	ldr	r3, [r2, #20]
 8001630:	69a9      	ldr	r1, [r5, #24]
 8001632:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001636:	430b      	orrs	r3, r1
 8001638:	6153      	str	r3, [r2, #20]
    if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
    {
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 800163a:	4b1f      	ldr	r3, [pc, #124]	; (80016b8 <UART_SetConfig+0xb8>)
 800163c:	429a      	cmp	r2, r3
 800163e:	d003      	beq.n	8001648 <UART_SetConfig+0x48>
 8001640:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001644:	429a      	cmp	r2, r3
 8001646:	d123      	bne.n	8001690 <UART_SetConfig+0x90>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 8001648:	f7ff ff9c 	bl	8001584 <HAL_RCC_GetPCLK2Freq>
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
    }
  /*-------------------------- USART BRR Configuration ---------------------*/
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800164c:	69eb      	ldr	r3, [r5, #28]
  {
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 800164e:	2119      	movs	r1, #25
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001650:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8001654:	e9d5 4600 	ldrd	r4, r6, [r5]
 8001658:	fba0 0101 	umull	r0, r1, r0, r1
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800165c:	d11b      	bne.n	8001696 <UART_SetConfig+0x96>
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 800165e:	19b2      	adds	r2, r6, r6
 8001660:	f04f 0300 	mov.w	r3, #0
 8001664:	415b      	adcs	r3, r3
 8001666:	f7fe fdc1 	bl	80001ec <__aeabi_uldivmod>
 800166a:	2164      	movs	r1, #100	; 0x64
 800166c:	fbb0 f5f1 	udiv	r5, r0, r1
 8001670:	fb01 0315 	mls	r3, r1, r5, r0
 8001674:	00db      	lsls	r3, r3, #3
 8001676:	3332      	adds	r3, #50	; 0x32
 8001678:	fbb3 f3f1 	udiv	r3, r3, r1
 800167c:	f003 0207 	and.w	r2, r3, #7
 8001680:	005b      	lsls	r3, r3, #1
 8001682:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 8001686:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 800168a:	4413      	add	r3, r2
  }
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 800168c:	60a3      	str	r3, [r4, #8]
  }
}
 800168e:	bd70      	pop	{r4, r5, r6, pc}
      pclk = HAL_RCC_GetPCLK1Freq();
 8001690:	f7ff ff68 	bl	8001564 <HAL_RCC_GetPCLK1Freq>
 8001694:	e7da      	b.n	800164c <UART_SetConfig+0x4c>
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8001696:	00b2      	lsls	r2, r6, #2
 8001698:	0fb3      	lsrs	r3, r6, #30
 800169a:	f7fe fda7 	bl	80001ec <__aeabi_uldivmod>
 800169e:	2264      	movs	r2, #100	; 0x64
 80016a0:	fbb0 f1f2 	udiv	r1, r0, r2
 80016a4:	fb02 0311 	mls	r3, r2, r1, r0
 80016a8:	011b      	lsls	r3, r3, #4
 80016aa:	3332      	adds	r3, #50	; 0x32
 80016ac:	fbb3 f3f2 	udiv	r3, r3, r2
 80016b0:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 80016b4:	e7ea      	b.n	800168c <UART_SetConfig+0x8c>
 80016b6:	bf00      	nop
 80016b8:	40011000 	.word	0x40011000

080016bc <UART_WaitOnFlagUntilTimeout.constprop.0>:
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
 80016bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80016be:	4604      	mov	r4, r0
 80016c0:	460e      	mov	r6, r1
 80016c2:	4617      	mov	r7, r2
 80016c4:	461d      	mov	r5, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80016c6:	6822      	ldr	r2, [r4, #0]
 80016c8:	6813      	ldr	r3, [r2, #0]
 80016ca:	ea36 0303 	bics.w	r3, r6, r3
 80016ce:	d101      	bne.n	80016d4 <UART_WaitOnFlagUntilTimeout.constprop.0+0x18>
  return HAL_OK;
 80016d0:	2000      	movs	r0, #0
 80016d2:	e028      	b.n	8001726 <UART_WaitOnFlagUntilTimeout.constprop.0+0x6a>
    if (Timeout != HAL_MAX_DELAY)
 80016d4:	1c6b      	adds	r3, r5, #1
 80016d6:	d0f7      	beq.n	80016c8 <UART_WaitOnFlagUntilTimeout.constprop.0+0xc>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 80016d8:	b125      	cbz	r5, 80016e4 <UART_WaitOnFlagUntilTimeout.constprop.0+0x28>
 80016da:	f7ff f93b 	bl	8000954 <HAL_GetTick>
 80016de:	1bc0      	subs	r0, r0, r7
 80016e0:	4285      	cmp	r5, r0
 80016e2:	d2f0      	bcs.n	80016c6 <UART_WaitOnFlagUntilTimeout.constprop.0+0xa>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80016e4:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80016e6:	f102 030c 	add.w	r3, r2, #12
 80016ea:	e853 3f00 	ldrex	r3, [r3]
 80016ee:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80016f2:	320c      	adds	r2, #12
 80016f4:	e842 3000 	strex	r0, r3, [r2]
   return(result);
 80016f8:	6821      	ldr	r1, [r4, #0]
 80016fa:	2800      	cmp	r0, #0
 80016fc:	d1f2      	bne.n	80016e4 <UART_WaitOnFlagUntilTimeout.constprop.0+0x28>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80016fe:	f101 0314 	add.w	r3, r1, #20
 8001702:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001706:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800170a:	f101 0014 	add.w	r0, r1, #20
 800170e:	e840 3200 	strex	r2, r3, [r0]
 8001712:	2a00      	cmp	r2, #0
 8001714:	d1f3      	bne.n	80016fe <UART_WaitOnFlagUntilTimeout.constprop.0+0x42>
        huart->gState  = HAL_UART_STATE_READY;
 8001716:	2320      	movs	r3, #32
 8001718:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        __HAL_UNLOCK(huart);
 800171c:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
        huart->RxState = HAL_UART_STATE_READY;
 8001720:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        __HAL_UNLOCK(huart);
 8001724:	2003      	movs	r0, #3
}
 8001726:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001728 <HAL_UART_Init>:
{
 8001728:	b510      	push	{r4, lr}
  if (huart == NULL)
 800172a:	4604      	mov	r4, r0
 800172c:	b340      	cbz	r0, 8001780 <HAL_UART_Init+0x58>
  if (huart->gState == HAL_UART_STATE_RESET)
 800172e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001732:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001736:	b91b      	cbnz	r3, 8001740 <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8001738:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_UART_MspInit(huart);
 800173c:	f7ff f838 	bl	80007b0 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8001740:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8001742:	2324      	movs	r3, #36	; 0x24
 8001744:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 8001748:	68d3      	ldr	r3, [r2, #12]
 800174a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800174e:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8001750:	4620      	mov	r0, r4
 8001752:	f7ff ff55 	bl	8001600 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001756:	6823      	ldr	r3, [r4, #0]
 8001758:	691a      	ldr	r2, [r3, #16]
 800175a:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800175e:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001760:	695a      	ldr	r2, [r3, #20]
 8001762:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8001766:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 8001768:	68da      	ldr	r2, [r3, #12]
 800176a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800176e:	60da      	str	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001770:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8001772:	2320      	movs	r3, #32
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001774:	6420      	str	r0, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 8001776:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 800177a:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 800177e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001780:	2001      	movs	r0, #1
 8001782:	e7fc      	b.n	800177e <HAL_UART_Init+0x56>

08001784 <HAL_UART_Transmit>:
{
 8001784:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8001786:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 8001788:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
{
 800178c:	9300      	str	r3, [sp, #0]
  if (huart->gState == HAL_UART_STATE_READY)
 800178e:	2a20      	cmp	r2, #32
{
 8001790:	4604      	mov	r4, r0
 8001792:	460e      	mov	r6, r1
  if (huart->gState == HAL_UART_STATE_READY)
 8001794:	d149      	bne.n	800182a <HAL_UART_Transmit+0xa6>
    if ((pData == NULL) || (Size == 0U))
 8001796:	2900      	cmp	r1, #0
 8001798:	d045      	beq.n	8001826 <HAL_UART_Transmit+0xa2>
 800179a:	2f00      	cmp	r7, #0
 800179c:	d043      	beq.n	8001826 <HAL_UART_Transmit+0xa2>
    __HAL_LOCK(huart);
 800179e:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 80017a2:	2a01      	cmp	r2, #1
 80017a4:	d041      	beq.n	800182a <HAL_UART_Transmit+0xa6>
 80017a6:	2201      	movs	r2, #1
 80017a8:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80017ac:	2500      	movs	r5, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80017ae:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80017b0:	6405      	str	r5, [r0, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80017b2:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
    tickstart = HAL_GetTick();
 80017b6:	f7ff f8cd 	bl	8000954 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80017ba:	68a1      	ldr	r1, [r4, #8]
 80017bc:	9b00      	ldr	r3, [sp, #0]
    huart->TxXferSize = Size;
 80017be:	84a7      	strh	r7, [r4, #36]	; 0x24
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80017c0:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
    tickstart = HAL_GetTick();
 80017c4:	4602      	mov	r2, r0
    huart->TxXferCount = Size;
 80017c6:	84e7      	strh	r7, [r4, #38]	; 0x26
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80017c8:	d103      	bne.n	80017d2 <HAL_UART_Transmit+0x4e>
 80017ca:	6921      	ldr	r1, [r4, #16]
 80017cc:	b909      	cbnz	r1, 80017d2 <HAL_UART_Transmit+0x4e>
 80017ce:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 80017d0:	460e      	mov	r6, r1
    __HAL_UNLOCK(huart);
 80017d2:	2100      	movs	r1, #0
 80017d4:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
    while (huart->TxXferCount > 0U)
 80017d8:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
 80017da:	b289      	uxth	r1, r1
 80017dc:	b941      	cbnz	r1, 80017f0 <HAL_UART_Transmit+0x6c>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80017de:	2140      	movs	r1, #64	; 0x40
 80017e0:	4620      	mov	r0, r4
 80017e2:	f7ff ff6b 	bl	80016bc <UART_WaitOnFlagUntilTimeout.constprop.0>
 80017e6:	b960      	cbnz	r0, 8001802 <HAL_UART_Transmit+0x7e>
    huart->gState = HAL_UART_STATE_READY;
 80017e8:	2320      	movs	r3, #32
 80017ea:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    return HAL_OK;
 80017ee:	e009      	b.n	8001804 <HAL_UART_Transmit+0x80>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80017f0:	2180      	movs	r1, #128	; 0x80
 80017f2:	4620      	mov	r0, r4
 80017f4:	e9cd 2300 	strd	r2, r3, [sp]
 80017f8:	f7ff ff60 	bl	80016bc <UART_WaitOnFlagUntilTimeout.constprop.0>
 80017fc:	e9dd 2300 	ldrd	r2, r3, [sp]
 8001800:	b110      	cbz	r0, 8001808 <HAL_UART_Transmit+0x84>
        return HAL_TIMEOUT;
 8001802:	2003      	movs	r0, #3
}
 8001804:	b003      	add	sp, #12
 8001806:	bdf0      	pop	{r4, r5, r6, r7, pc}
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 8001808:	6820      	ldr	r0, [r4, #0]
      if (pdata8bits == NULL)
 800180a:	b94e      	cbnz	r6, 8001820 <HAL_UART_Transmit+0x9c>
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 800180c:	f835 1b02 	ldrh.w	r1, [r5], #2
 8001810:	f3c1 0108 	ubfx	r1, r1, #0, #9
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 8001814:	6041      	str	r1, [r0, #4]
      huart->TxXferCount--;
 8001816:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
 8001818:	3901      	subs	r1, #1
 800181a:	b289      	uxth	r1, r1
 800181c:	84e1      	strh	r1, [r4, #38]	; 0x26
 800181e:	e7db      	b.n	80017d8 <HAL_UART_Transmit+0x54>
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 8001820:	f816 1b01 	ldrb.w	r1, [r6], #1
 8001824:	e7f6      	b.n	8001814 <HAL_UART_Transmit+0x90>
      return  HAL_ERROR;
 8001826:	2001      	movs	r0, #1
 8001828:	e7ec      	b.n	8001804 <HAL_UART_Transmit+0x80>
    return HAL_BUSY;
 800182a:	2002      	movs	r0, #2
 800182c:	e7ea      	b.n	8001804 <HAL_UART_Transmit+0x80>

0800182e <HAL_UART_TxCpltCallback>:
 800182e:	4770      	bx	lr

08001830 <HAL_UART_RxCpltCallback>:
 8001830:	4770      	bx	lr

08001832 <HAL_UART_RxHalfCpltCallback>:
 8001832:	4770      	bx	lr

08001834 <HAL_UART_ErrorCallback>:
 8001834:	4770      	bx	lr

08001836 <UART_DMAError>:
{
 8001836:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8001838:	6b80      	ldr	r0, [r0, #56]	; 0x38
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 800183a:	6803      	ldr	r3, [r0, #0]
 800183c:	695a      	ldr	r2, [r3, #20]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 800183e:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
 8001842:	2921      	cmp	r1, #33	; 0x21
 8001844:	d112      	bne.n	800186c <UART_DMAError+0x36>
 8001846:	0612      	lsls	r2, r2, #24
 8001848:	d510      	bpl.n	800186c <UART_DMAError+0x36>
    huart->TxXferCount = 0x00U;
 800184a:	2200      	movs	r2, #0
 800184c:	84c2      	strh	r2, [r0, #38]	; 0x26
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800184e:	f103 020c 	add.w	r2, r3, #12
 8001852:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8001856:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800185a:	f103 0c0c 	add.w	ip, r3, #12
 800185e:	e84c 2100 	strex	r1, r2, [ip]
 8001862:	2900      	cmp	r1, #0
 8001864:	d1f3      	bne.n	800184e <UART_DMAError+0x18>
  huart->gState = HAL_UART_STATE_READY;
 8001866:	2220      	movs	r2, #32
 8001868:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 800186c:	695b      	ldr	r3, [r3, #20]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 800186e:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8001872:	2a22      	cmp	r2, #34	; 0x22
 8001874:	d105      	bne.n	8001882 <UART_DMAError+0x4c>
 8001876:	065b      	lsls	r3, r3, #25
 8001878:	d503      	bpl.n	8001882 <UART_DMAError+0x4c>
    huart->RxXferCount = 0x00U;
 800187a:	2300      	movs	r3, #0
 800187c:	85c3      	strh	r3, [r0, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 800187e:	f7ff fe91 	bl	80015a4 <UART_EndRxTransfer>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8001882:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001884:	f043 0310 	orr.w	r3, r3, #16
 8001888:	6403      	str	r3, [r0, #64]	; 0x40
  HAL_UART_ErrorCallback(huart);
 800188a:	f7ff ffd3 	bl	8001834 <HAL_UART_ErrorCallback>
}
 800188e:	bd08      	pop	{r3, pc}

08001890 <UART_DMAAbortOnError>:
{
 8001890:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8001892:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0x00U;
 8001894:	2300      	movs	r3, #0
 8001896:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 8001898:	84c3      	strh	r3, [r0, #38]	; 0x26
  HAL_UART_ErrorCallback(huart);
 800189a:	f7ff ffcb 	bl	8001834 <HAL_UART_ErrorCallback>
}
 800189e:	bd08      	pop	{r3, pc}

080018a0 <UART_DMARxHalfCplt>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80018a0:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 80018a2:	b508      	push	{r3, lr}
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80018a4:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80018a6:	2b01      	cmp	r3, #1
 80018a8:	d104      	bne.n	80018b4 <UART_DMARxHalfCplt+0x14>
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
 80018aa:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
 80018ac:	0849      	lsrs	r1, r1, #1
 80018ae:	f7fe fe57 	bl	8000560 <HAL_UARTEx_RxEventCallback>
}
 80018b2:	bd08      	pop	{r3, pc}
    HAL_UART_RxHalfCpltCallback(huart);
 80018b4:	f7ff ffbd 	bl	8001832 <HAL_UART_RxHalfCpltCallback>
}
 80018b8:	e7fb      	b.n	80018b2 <UART_DMARxHalfCplt+0x12>

080018ba <UART_DMAReceiveCplt>:
{
 80018ba:	b508      	push	{r3, lr}
 80018bc:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80018be:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 80018c0:	681b      	ldr	r3, [r3, #0]
 80018c2:	681b      	ldr	r3, [r3, #0]
 80018c4:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 80018c8:	d137      	bne.n	800193a <UART_DMAReceiveCplt+0x80>
    huart->RxXferCount = 0U;
 80018ca:	85c3      	strh	r3, [r0, #46]	; 0x2e
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80018cc:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80018ce:	f102 030c 	add.w	r3, r2, #12
 80018d2:	e853 3f00 	ldrex	r3, [r3]
 80018d6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80018da:	320c      	adds	r2, #12
 80018dc:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80018e0:	6803      	ldr	r3, [r0, #0]
 80018e2:	2900      	cmp	r1, #0
 80018e4:	d1f2      	bne.n	80018cc <UART_DMAReceiveCplt+0x12>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80018e6:	f103 0214 	add.w	r2, r3, #20
 80018ea:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80018ee:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80018f2:	f103 0c14 	add.w	ip, r3, #20
 80018f6:	e84c 2100 	strex	r1, r2, [ip]
 80018fa:	2900      	cmp	r1, #0
 80018fc:	d1f3      	bne.n	80018e6 <UART_DMAReceiveCplt+0x2c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80018fe:	f103 0214 	add.w	r2, r3, #20
 8001902:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001906:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800190a:	f103 0c14 	add.w	ip, r3, #20
 800190e:	e84c 2100 	strex	r1, r2, [ip]
 8001912:	2900      	cmp	r1, #0
 8001914:	d1f3      	bne.n	80018fe <UART_DMAReceiveCplt+0x44>
    huart->RxState = HAL_UART_STATE_READY;
 8001916:	2220      	movs	r2, #32
 8001918:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800191c:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800191e:	2a01      	cmp	r2, #1
 8001920:	d10b      	bne.n	800193a <UART_DMAReceiveCplt+0x80>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001922:	f103 020c 	add.w	r2, r3, #12
 8001926:	e852 2f00 	ldrex	r2, [r2]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800192a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800192e:	f103 0c0c 	add.w	ip, r3, #12
 8001932:	e84c 2100 	strex	r1, r2, [ip]
 8001936:	2900      	cmp	r1, #0
 8001938:	d1f3      	bne.n	8001922 <UART_DMAReceiveCplt+0x68>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800193a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800193c:	2b01      	cmp	r3, #1
 800193e:	d103      	bne.n	8001948 <UART_DMAReceiveCplt+0x8e>
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8001940:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
 8001942:	f7fe fe0d 	bl	8000560 <HAL_UARTEx_RxEventCallback>
}
 8001946:	bd08      	pop	{r3, pc}
    HAL_UART_RxCpltCallback(huart);
 8001948:	f7ff ff72 	bl	8001830 <HAL_UART_RxCpltCallback>
}
 800194c:	e7fb      	b.n	8001946 <UART_DMAReceiveCplt+0x8c>

0800194e <UART_Receive_IT.part.0.isra.0>:
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
 800194e:	b507      	push	{r0, r1, r2, lr}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001950:	6881      	ldr	r1, [r0, #8]
      pdata16bits = (uint16_t *) huart->pRxBuffPtr;
 8001952:	6a83      	ldr	r3, [r0, #40]	; 0x28
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001954:	6802      	ldr	r2, [r0, #0]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001956:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 800195a:	d13e      	bne.n	80019da <UART_Receive_IT.part.0.isra.0+0x8c>
 800195c:	6901      	ldr	r1, [r0, #16]
 800195e:	2900      	cmp	r1, #0
 8001960:	d13e      	bne.n	80019e0 <UART_Receive_IT.part.0.isra.0+0x92>
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001962:	6852      	ldr	r2, [r2, #4]
 8001964:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8001968:	f823 2b02 	strh.w	r2, [r3], #2
      huart->pRxBuffPtr += 1U;
 800196c:	6283      	str	r3, [r0, #40]	; 0x28
    if (--huart->RxXferCount == 0U)
 800196e:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8001970:	3b01      	subs	r3, #1
 8001972:	b29b      	uxth	r3, r3
 8001974:	85c3      	strh	r3, [r0, #46]	; 0x2e
 8001976:	2b00      	cmp	r3, #0
 8001978:	d12c      	bne.n	80019d4 <UART_Receive_IT.part.0.isra.0+0x86>
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800197a:	6802      	ldr	r2, [r0, #0]
 800197c:	68d1      	ldr	r1, [r2, #12]
 800197e:	f021 0120 	bic.w	r1, r1, #32
 8001982:	60d1      	str	r1, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8001984:	68d1      	ldr	r1, [r2, #12]
 8001986:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 800198a:	60d1      	str	r1, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800198c:	6951      	ldr	r1, [r2, #20]
 800198e:	f021 0101 	bic.w	r1, r1, #1
 8001992:	6151      	str	r1, [r2, #20]
      huart->RxState = HAL_UART_STATE_READY;
 8001994:	2220      	movs	r2, #32
 8001996:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800199a:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800199c:	2a01      	cmp	r2, #1
 800199e:	6802      	ldr	r2, [r0, #0]
 80019a0:	d128      	bne.n	80019f4 <UART_Receive_IT.part.0.isra.0+0xa6>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80019a2:	6303      	str	r3, [r0, #48]	; 0x30
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80019a4:	f102 030c 	add.w	r3, r2, #12
 80019a8:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80019ac:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80019b0:	f102 0c0c 	add.w	ip, r2, #12
 80019b4:	e84c 3100 	strex	r1, r3, [ip]
 80019b8:	2900      	cmp	r1, #0
 80019ba:	d1f3      	bne.n	80019a4 <UART_Receive_IT.part.0.isra.0+0x56>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
 80019bc:	6813      	ldr	r3, [r2, #0]
 80019be:	06db      	lsls	r3, r3, #27
 80019c0:	d505      	bpl.n	80019ce <UART_Receive_IT.part.0.isra.0+0x80>
          __HAL_UART_CLEAR_IDLEFLAG(huart);
 80019c2:	9101      	str	r1, [sp, #4]
 80019c4:	6813      	ldr	r3, [r2, #0]
 80019c6:	9301      	str	r3, [sp, #4]
 80019c8:	6853      	ldr	r3, [r2, #4]
 80019ca:	9301      	str	r3, [sp, #4]
 80019cc:	9b01      	ldr	r3, [sp, #4]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80019ce:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
 80019d0:	f7fe fdc6 	bl	8000560 <HAL_UARTEx_RxEventCallback>
}
 80019d4:	b003      	add	sp, #12
 80019d6:	f85d fb04 	ldr.w	pc, [sp], #4
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 80019da:	b939      	cbnz	r1, 80019ec <UART_Receive_IT.part.0.isra.0+0x9e>
 80019dc:	6901      	ldr	r1, [r0, #16]
 80019de:	b929      	cbnz	r1, 80019ec <UART_Receive_IT.part.0.isra.0+0x9e>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 80019e0:	6852      	ldr	r2, [r2, #4]
 80019e2:	b2d2      	uxtb	r2, r2
 80019e4:	701a      	strb	r2, [r3, #0]
      huart->pRxBuffPtr += 1U;
 80019e6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80019e8:	3301      	adds	r3, #1
 80019ea:	e7bf      	b.n	800196c <UART_Receive_IT.part.0.isra.0+0x1e>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 80019ec:	6852      	ldr	r2, [r2, #4]
 80019ee:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80019f2:	e7f7      	b.n	80019e4 <UART_Receive_IT.part.0.isra.0+0x96>
        HAL_UART_RxCpltCallback(huart);
 80019f4:	f7ff ff1c 	bl	8001830 <HAL_UART_RxCpltCallback>
 80019f8:	e7ec      	b.n	80019d4 <UART_Receive_IT.part.0.isra.0+0x86>
	...

080019fc <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 80019fc:	6803      	ldr	r3, [r0, #0]
{
 80019fe:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8001a00:	681a      	ldr	r2, [r3, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8001a02:	68d9      	ldr	r1, [r3, #12]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8001a04:	695d      	ldr	r5, [r3, #20]
  if (errorflags == RESET)
 8001a06:	f012 0f0f 	tst.w	r2, #15
{
 8001a0a:	4604      	mov	r4, r0
  if (errorflags == RESET)
 8001a0c:	d10c      	bne.n	8001a28 <HAL_UART_IRQHandler+0x2c>
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8001a0e:	0695      	lsls	r5, r2, #26
 8001a10:	d570      	bpl.n	8001af4 <HAL_UART_IRQHandler+0xf8>
 8001a12:	068d      	lsls	r5, r1, #26
 8001a14:	d56e      	bpl.n	8001af4 <HAL_UART_IRQHandler+0xf8>
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8001a16:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8001a1a:	2b22      	cmp	r3, #34	; 0x22
 8001a1c:	d164      	bne.n	8001ae8 <HAL_UART_IRQHandler+0xec>
}
 8001a1e:	b003      	add	sp, #12
 8001a20:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8001a24:	f7ff bf93 	b.w	800194e <UART_Receive_IT.part.0.isra.0>
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
 8001a28:	f005 0001 	and.w	r0, r5, #1
                                || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8001a2c:	f401 7590 	and.w	r5, r1, #288	; 0x120
 8001a30:	4305      	orrs	r5, r0
 8001a32:	d05f      	beq.n	8001af4 <HAL_UART_IRQHandler+0xf8>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8001a34:	07d5      	lsls	r5, r2, #31
 8001a36:	d505      	bpl.n	8001a44 <HAL_UART_IRQHandler+0x48>
 8001a38:	05cb      	lsls	r3, r1, #23
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8001a3a:	bf42      	ittt	mi
 8001a3c:	6c23      	ldrmi	r3, [r4, #64]	; 0x40
 8001a3e:	f043 0301 	orrmi.w	r3, r3, #1
 8001a42:	6423      	strmi	r3, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001a44:	0755      	lsls	r5, r2, #29
 8001a46:	d504      	bpl.n	8001a52 <HAL_UART_IRQHandler+0x56>
 8001a48:	b118      	cbz	r0, 8001a52 <HAL_UART_IRQHandler+0x56>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001a4a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001a4c:	f043 0302 	orr.w	r3, r3, #2
 8001a50:	6423      	str	r3, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001a52:	0793      	lsls	r3, r2, #30
 8001a54:	d504      	bpl.n	8001a60 <HAL_UART_IRQHandler+0x64>
 8001a56:	b118      	cbz	r0, 8001a60 <HAL_UART_IRQHandler+0x64>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8001a58:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001a5a:	f043 0304 	orr.w	r3, r3, #4
 8001a5e:	6423      	str	r3, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
 8001a60:	0715      	lsls	r5, r2, #28
 8001a62:	d507      	bpl.n	8001a74 <HAL_UART_IRQHandler+0x78>
 8001a64:	f001 0320 	and.w	r3, r1, #32
 8001a68:	4303      	orrs	r3, r0
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8001a6a:	bf1e      	ittt	ne
 8001a6c:	6c23      	ldrne	r3, [r4, #64]	; 0x40
 8001a6e:	f043 0308 	orrne.w	r3, r3, #8
 8001a72:	6423      	strne	r3, [r4, #64]	; 0x40
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8001a74:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001a76:	2b00      	cmp	r3, #0
 8001a78:	d036      	beq.n	8001ae8 <HAL_UART_IRQHandler+0xec>
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8001a7a:	0690      	lsls	r0, r2, #26
 8001a7c:	d508      	bpl.n	8001a90 <HAL_UART_IRQHandler+0x94>
 8001a7e:	068a      	lsls	r2, r1, #26
 8001a80:	d506      	bpl.n	8001a90 <HAL_UART_IRQHandler+0x94>
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8001a82:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8001a86:	2b22      	cmp	r3, #34	; 0x22
 8001a88:	d102      	bne.n	8001a90 <HAL_UART_IRQHandler+0x94>
 8001a8a:	4620      	mov	r0, r4
 8001a8c:	f7ff ff5f 	bl	800194e <UART_Receive_IT.part.0.isra.0>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8001a90:	6823      	ldr	r3, [r4, #0]
 8001a92:	695b      	ldr	r3, [r3, #20]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8001a94:	6c25      	ldr	r5, [r4, #64]	; 0x40
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8001a96:	f003 0340 	and.w	r3, r3, #64	; 0x40
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8001a9a:	f005 0508 	and.w	r5, r5, #8
 8001a9e:	431d      	orrs	r5, r3
        UART_EndRxTransfer(huart);
 8001aa0:	4620      	mov	r0, r4
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8001aa2:	d023      	beq.n	8001aec <HAL_UART_IRQHandler+0xf0>
        UART_EndRxTransfer(huart);
 8001aa4:	f7ff fd7e 	bl	80015a4 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8001aa8:	6822      	ldr	r2, [r4, #0]
 8001aaa:	6953      	ldr	r3, [r2, #20]
 8001aac:	065b      	lsls	r3, r3, #25
 8001aae:	d518      	bpl.n	8001ae2 <HAL_UART_IRQHandler+0xe6>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001ab0:	f102 0314 	add.w	r3, r2, #20
 8001ab4:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001ab8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001abc:	f102 0014 	add.w	r0, r2, #20
 8001ac0:	e840 3100 	strex	r1, r3, [r0]
 8001ac4:	2900      	cmp	r1, #0
 8001ac6:	d1f3      	bne.n	8001ab0 <HAL_UART_IRQHandler+0xb4>
          if (huart->hdmarx != NULL)
 8001ac8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001aca:	b150      	cbz	r0, 8001ae2 <HAL_UART_IRQHandler+0xe6>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8001acc:	4b72      	ldr	r3, [pc, #456]	; (8001c98 <HAL_UART_IRQHandler+0x29c>)
 8001ace:	6503      	str	r3, [r0, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8001ad0:	f7ff f8d4 	bl	8000c7c <HAL_DMA_Abort_IT>
 8001ad4:	b140      	cbz	r0, 8001ae8 <HAL_UART_IRQHandler+0xec>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8001ad6:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001ad8:	6d03      	ldr	r3, [r0, #80]	; 0x50
}
 8001ada:	b003      	add	sp, #12
 8001adc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8001ae0:	4718      	bx	r3
            HAL_UART_ErrorCallback(huart);
 8001ae2:	4620      	mov	r0, r4
 8001ae4:	f7ff fea6 	bl	8001834 <HAL_UART_ErrorCallback>
}
 8001ae8:	b003      	add	sp, #12
 8001aea:	bd30      	pop	{r4, r5, pc}
        HAL_UART_ErrorCallback(huart);
 8001aec:	f7ff fea2 	bl	8001834 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001af0:	6425      	str	r5, [r4, #64]	; 0x40
 8001af2:	e7f9      	b.n	8001ae8 <HAL_UART_IRQHandler+0xec>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8001af4:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001af6:	2801      	cmp	r0, #1
 8001af8:	f040 8091 	bne.w	8001c1e <HAL_UART_IRQHandler+0x222>
      && ((isrflags & USART_SR_IDLE) != 0U)
 8001afc:	06d5      	lsls	r5, r2, #27
 8001afe:	f140 808e 	bpl.w	8001c1e <HAL_UART_IRQHandler+0x222>
      && ((cr1its & USART_SR_IDLE) != 0U))
 8001b02:	06c8      	lsls	r0, r1, #27
 8001b04:	f140 808b 	bpl.w	8001c1e <HAL_UART_IRQHandler+0x222>
    __HAL_UART_CLEAR_IDLEFLAG(huart);
 8001b08:	2200      	movs	r2, #0
 8001b0a:	9201      	str	r2, [sp, #4]
 8001b0c:	681a      	ldr	r2, [r3, #0]
 8001b0e:	9201      	str	r2, [sp, #4]
 8001b10:	685a      	ldr	r2, [r3, #4]
 8001b12:	9201      	str	r2, [sp, #4]
 8001b14:	9a01      	ldr	r2, [sp, #4]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8001b16:	695a      	ldr	r2, [r3, #20]
 8001b18:	0655      	lsls	r5, r2, #25
 8001b1a:	d54c      	bpl.n	8001bb6 <HAL_UART_IRQHandler+0x1ba>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8001b1c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8001b1e:	680a      	ldr	r2, [r1, #0]
 8001b20:	6852      	ldr	r2, [r2, #4]
 8001b22:	b292      	uxth	r2, r2
      if ((nb_remaining_rx_data > 0U)
 8001b24:	2a00      	cmp	r2, #0
 8001b26:	d0df      	beq.n	8001ae8 <HAL_UART_IRQHandler+0xec>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8001b28:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 8001b2a:	4290      	cmp	r0, r2
 8001b2c:	d9dc      	bls.n	8001ae8 <HAL_UART_IRQHandler+0xec>
        huart->RxXferCount = nb_remaining_rx_data;
 8001b2e:	85e2      	strh	r2, [r4, #46]	; 0x2e
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 8001b30:	69ca      	ldr	r2, [r1, #28]
 8001b32:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8001b36:	d036      	beq.n	8001ba6 <HAL_UART_IRQHandler+0x1aa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001b38:	f103 020c 	add.w	r2, r3, #12
 8001b3c:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8001b40:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001b44:	f103 000c 	add.w	r0, r3, #12
 8001b48:	e840 2100 	strex	r1, r2, [r0]
 8001b4c:	2900      	cmp	r1, #0
 8001b4e:	d1f3      	bne.n	8001b38 <HAL_UART_IRQHandler+0x13c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001b50:	f103 0214 	add.w	r2, r3, #20
 8001b54:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001b58:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001b5c:	f103 0014 	add.w	r0, r3, #20
 8001b60:	e840 2100 	strex	r1, r2, [r0]
 8001b64:	2900      	cmp	r1, #0
 8001b66:	d1f3      	bne.n	8001b50 <HAL_UART_IRQHandler+0x154>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001b68:	f103 0214 	add.w	r2, r3, #20
 8001b6c:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001b70:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001b74:	f103 0014 	add.w	r0, r3, #20
 8001b78:	e840 2100 	strex	r1, r2, [r0]
 8001b7c:	2900      	cmp	r1, #0
 8001b7e:	d1f3      	bne.n	8001b68 <HAL_UART_IRQHandler+0x16c>
          huart->RxState = HAL_UART_STATE_READY;
 8001b80:	2220      	movs	r2, #32
 8001b82:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8001b86:	6321      	str	r1, [r4, #48]	; 0x30
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001b88:	f103 020c 	add.w	r2, r3, #12
 8001b8c:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8001b90:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001b94:	f103 000c 	add.w	r0, r3, #12
 8001b98:	e840 2100 	strex	r1, r2, [r0]
 8001b9c:	2900      	cmp	r1, #0
 8001b9e:	d1f3      	bne.n	8001b88 <HAL_UART_IRQHandler+0x18c>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8001ba0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001ba2:	f7ff f827 	bl	8000bf4 <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8001ba6:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8001ba8:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 8001baa:	1ac9      	subs	r1, r1, r3
 8001bac:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8001bae:	4620      	mov	r0, r4
 8001bb0:	f7fe fcd6 	bl	8000560 <HAL_UARTEx_RxEventCallback>
 8001bb4:	e798      	b.n	8001ae8 <HAL_UART_IRQHandler+0xec>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8001bb6:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
 8001bb8:	b28a      	uxth	r2, r1
      if ((huart->RxXferCount > 0U)
 8001bba:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
 8001bbc:	b289      	uxth	r1, r1
 8001bbe:	2900      	cmp	r1, #0
 8001bc0:	d092      	beq.n	8001ae8 <HAL_UART_IRQHandler+0xec>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8001bc2:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 8001bc4:	1a89      	subs	r1, r1, r2
 8001bc6:	b289      	uxth	r1, r1
          && (nb_rx_data > 0U))
 8001bc8:	2900      	cmp	r1, #0
 8001bca:	d08d      	beq.n	8001ae8 <HAL_UART_IRQHandler+0xec>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001bcc:	f103 020c 	add.w	r2, r3, #12
 8001bd0:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001bd4:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001bd8:	f103 050c 	add.w	r5, r3, #12
 8001bdc:	e845 2000 	strex	r0, r2, [r5]
 8001be0:	2800      	cmp	r0, #0
 8001be2:	d1f3      	bne.n	8001bcc <HAL_UART_IRQHandler+0x1d0>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001be4:	f103 0214 	add.w	r2, r3, #20
 8001be8:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001bec:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001bf0:	f103 0514 	add.w	r5, r3, #20
 8001bf4:	e845 2000 	strex	r0, r2, [r5]
 8001bf8:	2800      	cmp	r0, #0
 8001bfa:	d1f3      	bne.n	8001be4 <HAL_UART_IRQHandler+0x1e8>
        huart->RxState = HAL_UART_STATE_READY;
 8001bfc:	2220      	movs	r2, #32
 8001bfe:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8001c02:	6320      	str	r0, [r4, #48]	; 0x30
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001c04:	f103 020c 	add.w	r2, r3, #12
 8001c08:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8001c0c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001c10:	f103 050c 	add.w	r5, r3, #12
 8001c14:	e845 2000 	strex	r0, r2, [r5]
 8001c18:	2800      	cmp	r0, #0
 8001c1a:	d1f3      	bne.n	8001c04 <HAL_UART_IRQHandler+0x208>
 8001c1c:	e7c7      	b.n	8001bae <HAL_UART_IRQHandler+0x1b2>
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8001c1e:	0610      	lsls	r0, r2, #24
 8001c20:	d528      	bpl.n	8001c74 <HAL_UART_IRQHandler+0x278>
 8001c22:	060d      	lsls	r5, r1, #24
 8001c24:	d526      	bpl.n	8001c74 <HAL_UART_IRQHandler+0x278>
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8001c26:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8001c2a:	2a21      	cmp	r2, #33	; 0x21
 8001c2c:	f47f af5c 	bne.w	8001ae8 <HAL_UART_IRQHandler+0xec>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001c30:	68a1      	ldr	r1, [r4, #8]
      tmp = (const uint16_t *) huart->pTxBuffPtr;
 8001c32:	6a22      	ldr	r2, [r4, #32]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001c34:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8001c38:	d117      	bne.n	8001c6a <HAL_UART_IRQHandler+0x26e>
 8001c3a:	6921      	ldr	r1, [r4, #16]
 8001c3c:	b9a9      	cbnz	r1, 8001c6a <HAL_UART_IRQHandler+0x26e>
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8001c3e:	f832 1b02 	ldrh.w	r1, [r2], #2
 8001c42:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8001c46:	6059      	str	r1, [r3, #4]
      huart->pTxBuffPtr += 2U;
 8001c48:	6222      	str	r2, [r4, #32]
    if (--huart->TxXferCount == 0U)
 8001c4a:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8001c4c:	3a01      	subs	r2, #1
 8001c4e:	b292      	uxth	r2, r2
 8001c50:	84e2      	strh	r2, [r4, #38]	; 0x26
 8001c52:	2a00      	cmp	r2, #0
 8001c54:	f47f af48 	bne.w	8001ae8 <HAL_UART_IRQHandler+0xec>
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8001c58:	68da      	ldr	r2, [r3, #12]
 8001c5a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001c5e:	60da      	str	r2, [r3, #12]
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8001c60:	68da      	ldr	r2, [r3, #12]
 8001c62:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001c66:	60da      	str	r2, [r3, #12]
 8001c68:	e73e      	b.n	8001ae8 <HAL_UART_IRQHandler+0xec>
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8001c6a:	1c51      	adds	r1, r2, #1
 8001c6c:	6221      	str	r1, [r4, #32]
 8001c6e:	7812      	ldrb	r2, [r2, #0]
 8001c70:	605a      	str	r2, [r3, #4]
 8001c72:	e7ea      	b.n	8001c4a <HAL_UART_IRQHandler+0x24e>
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8001c74:	0650      	lsls	r0, r2, #25
 8001c76:	f57f af37 	bpl.w	8001ae8 <HAL_UART_IRQHandler+0xec>
 8001c7a:	064a      	lsls	r2, r1, #25
 8001c7c:	f57f af34 	bpl.w	8001ae8 <HAL_UART_IRQHandler+0xec>
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8001c80:	68da      	ldr	r2, [r3, #12]
 8001c82:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001c86:	60da      	str	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 8001c88:	2320      	movs	r3, #32
 8001c8a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  HAL_UART_TxCpltCallback(huart);
 8001c8e:	4620      	mov	r0, r4
 8001c90:	f7ff fdcd 	bl	800182e <HAL_UART_TxCpltCallback>
  return HAL_OK;
 8001c94:	e728      	b.n	8001ae8 <HAL_UART_IRQHandler+0xec>
 8001c96:	bf00      	nop
 8001c98:	08001891 	.word	0x08001891

08001c9c <UART_Start_Receive_DMA>:
{
 8001c9c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8001c9e:	2322      	movs	r3, #34	; 0x22
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001ca0:	2500      	movs	r5, #0
{
 8001ca2:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001ca4:	6405      	str	r5, [r0, #64]	; 0x40
  huart->pRxBuffPtr = pData;
 8001ca6:	6281      	str	r1, [r0, #40]	; 0x28
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8001ca8:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
  huart->RxXferSize = Size;
 8001cac:	8582      	strh	r2, [r0, #44]	; 0x2c
  huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8001cae:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8001cb0:	4b1e      	ldr	r3, [pc, #120]	; (8001d2c <UART_Start_Receive_DMA+0x90>)
 8001cb2:	63c3      	str	r3, [r0, #60]	; 0x3c
  huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8001cb4:	4b1e      	ldr	r3, [pc, #120]	; (8001d30 <UART_Start_Receive_DMA+0x94>)
  HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
 8001cb6:	6826      	ldr	r6, [r4, #0]
  huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8001cb8:	6403      	str	r3, [r0, #64]	; 0x40
  huart->hdmarx->XferErrorCallback = UART_DMAError;
 8001cba:	4b1e      	ldr	r3, [pc, #120]	; (8001d34 <UART_Start_Receive_DMA+0x98>)
  huart->hdmarx->XferAbortCallback = NULL;
 8001cbc:	e9c0 3513 	strd	r3, r5, [r0, #76]	; 0x4c
  HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
 8001cc0:	4613      	mov	r3, r2
 8001cc2:	460a      	mov	r2, r1
 8001cc4:	1d31      	adds	r1, r6, #4
 8001cc6:	f7fe ff5b 	bl	8000b80 <HAL_DMA_Start_IT>
  __HAL_UART_CLEAR_OREFLAG(huart);
 8001cca:	6823      	ldr	r3, [r4, #0]
 8001ccc:	9501      	str	r5, [sp, #4]
 8001cce:	681a      	ldr	r2, [r3, #0]
 8001cd0:	9201      	str	r2, [sp, #4]
 8001cd2:	685a      	ldr	r2, [r3, #4]
 8001cd4:	9201      	str	r2, [sp, #4]
 8001cd6:	9a01      	ldr	r2, [sp, #4]
  if (huart->Init.Parity != UART_PARITY_NONE)
 8001cd8:	6922      	ldr	r2, [r4, #16]
  __HAL_UNLOCK(huart);
 8001cda:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
  if (huart->Init.Parity != UART_PARITY_NONE)
 8001cde:	b15a      	cbz	r2, 8001cf8 <UART_Start_Receive_DMA+0x5c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001ce0:	f103 020c 	add.w	r2, r3, #12
 8001ce4:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8001ce8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001cec:	f103 000c 	add.w	r0, r3, #12
 8001cf0:	e840 2100 	strex	r1, r2, [r0]
 8001cf4:	2900      	cmp	r1, #0
 8001cf6:	d1f3      	bne.n	8001ce0 <UART_Start_Receive_DMA+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001cf8:	f103 0214 	add.w	r2, r3, #20
 8001cfc:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001d00:	f042 0201 	orr.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001d04:	f103 0014 	add.w	r0, r3, #20
 8001d08:	e840 2100 	strex	r1, r2, [r0]
 8001d0c:	2900      	cmp	r1, #0
 8001d0e:	d1f3      	bne.n	8001cf8 <UART_Start_Receive_DMA+0x5c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001d10:	f103 0214 	add.w	r2, r3, #20
 8001d14:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001d18:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001d1c:	f103 0114 	add.w	r1, r3, #20
 8001d20:	e841 2000 	strex	r0, r2, [r1]
 8001d24:	2800      	cmp	r0, #0
 8001d26:	d1f3      	bne.n	8001d10 <UART_Start_Receive_DMA+0x74>
}
 8001d28:	b002      	add	sp, #8
 8001d2a:	bd70      	pop	{r4, r5, r6, pc}
 8001d2c:	080018bb 	.word	0x080018bb
 8001d30:	080018a1 	.word	0x080018a1
 8001d34:	08001837 	.word	0x08001837

08001d38 <HAL_UARTEx_ReceiveToIdle_DMA>:
{
 8001d38:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 8001d3a:	f890 603e 	ldrb.w	r6, [r0, #62]	; 0x3e
 8001d3e:	2e20      	cmp	r6, #32
{
 8001d40:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 8001d42:	d128      	bne.n	8001d96 <HAL_UARTEx_ReceiveToIdle_DMA+0x5e>
    if ((pData == NULL) || (Size == 0U))
 8001d44:	b911      	cbnz	r1, 8001d4c <HAL_UARTEx_ReceiveToIdle_DMA+0x14>
      return HAL_ERROR;
 8001d46:	2001      	movs	r0, #1
}
 8001d48:	b002      	add	sp, #8
 8001d4a:	bd70      	pop	{r4, r5, r6, pc}
    if ((pData == NULL) || (Size == 0U))
 8001d4c:	2a00      	cmp	r2, #0
 8001d4e:	d0fa      	beq.n	8001d46 <HAL_UARTEx_ReceiveToIdle_DMA+0xe>
    __HAL_LOCK(huart);
 8001d50:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8001d54:	2b01      	cmp	r3, #1
 8001d56:	d01e      	beq.n	8001d96 <HAL_UARTEx_ReceiveToIdle_DMA+0x5e>
 8001d58:	2301      	movs	r3, #1
 8001d5a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
 8001d5e:	6303      	str	r3, [r0, #48]	; 0x30
    status =  UART_Start_Receive_DMA(huart, pData, Size);
 8001d60:	f7ff ff9c 	bl	8001c9c <UART_Start_Receive_DMA>
    if (status == HAL_OK)
 8001d64:	2800      	cmp	r0, #0
 8001d66:	d1ef      	bne.n	8001d48 <HAL_UARTEx_ReceiveToIdle_DMA+0x10>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8001d68:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001d6a:	2b01      	cmp	r3, #1
 8001d6c:	d1eb      	bne.n	8001d46 <HAL_UARTEx_ReceiveToIdle_DMA+0xe>
        __HAL_UART_CLEAR_IDLEFLAG(huart);
 8001d6e:	6822      	ldr	r2, [r4, #0]
 8001d70:	9001      	str	r0, [sp, #4]
 8001d72:	6813      	ldr	r3, [r2, #0]
 8001d74:	9301      	str	r3, [sp, #4]
 8001d76:	6853      	ldr	r3, [r2, #4]
 8001d78:	9301      	str	r3, [sp, #4]
 8001d7a:	9b01      	ldr	r3, [sp, #4]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001d7c:	f102 030c 	add.w	r3, r2, #12
 8001d80:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8001d84:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001d88:	f102 040c 	add.w	r4, r2, #12
 8001d8c:	e844 3100 	strex	r1, r3, [r4]
 8001d90:	2900      	cmp	r1, #0
 8001d92:	d1f3      	bne.n	8001d7c <HAL_UARTEx_ReceiveToIdle_DMA+0x44>
 8001d94:	e7d8      	b.n	8001d48 <HAL_UARTEx_ReceiveToIdle_DMA+0x10>
    return HAL_BUSY;
 8001d96:	2002      	movs	r0, #2
 8001d98:	e7d6      	b.n	8001d48 <HAL_UARTEx_ReceiveToIdle_DMA+0x10>
	...

08001d9c <__libc_init_array>:
 8001d9c:	b570      	push	{r4, r5, r6, lr}
 8001d9e:	4d0d      	ldr	r5, [pc, #52]	; (8001dd4 <__libc_init_array+0x38>)
 8001da0:	4c0d      	ldr	r4, [pc, #52]	; (8001dd8 <__libc_init_array+0x3c>)
 8001da2:	1b64      	subs	r4, r4, r5
 8001da4:	10a4      	asrs	r4, r4, #2
 8001da6:	2600      	movs	r6, #0
 8001da8:	42a6      	cmp	r6, r4
 8001daa:	d109      	bne.n	8001dc0 <__libc_init_array+0x24>
 8001dac:	4d0b      	ldr	r5, [pc, #44]	; (8001ddc <__libc_init_array+0x40>)
 8001dae:	4c0c      	ldr	r4, [pc, #48]	; (8001de0 <__libc_init_array+0x44>)
 8001db0:	f000 f820 	bl	8001df4 <_init>
 8001db4:	1b64      	subs	r4, r4, r5
 8001db6:	10a4      	asrs	r4, r4, #2
 8001db8:	2600      	movs	r6, #0
 8001dba:	42a6      	cmp	r6, r4
 8001dbc:	d105      	bne.n	8001dca <__libc_init_array+0x2e>
 8001dbe:	bd70      	pop	{r4, r5, r6, pc}
 8001dc0:	f855 3b04 	ldr.w	r3, [r5], #4
 8001dc4:	4798      	blx	r3
 8001dc6:	3601      	adds	r6, #1
 8001dc8:	e7ee      	b.n	8001da8 <__libc_init_array+0xc>
 8001dca:	f855 3b04 	ldr.w	r3, [r5], #4
 8001dce:	4798      	blx	r3
 8001dd0:	3601      	adds	r6, #1
 8001dd2:	e7f2      	b.n	8001dba <__libc_init_array+0x1e>
 8001dd4:	08001e34 	.word	0x08001e34
 8001dd8:	08001e34 	.word	0x08001e34
 8001ddc:	08001e34 	.word	0x08001e34
 8001de0:	08001e38 	.word	0x08001e38

08001de4 <memset>:
 8001de4:	4402      	add	r2, r0
 8001de6:	4603      	mov	r3, r0
 8001de8:	4293      	cmp	r3, r2
 8001dea:	d100      	bne.n	8001dee <memset+0xa>
 8001dec:	4770      	bx	lr
 8001dee:	f803 1b01 	strb.w	r1, [r3], #1
 8001df2:	e7f9      	b.n	8001de8 <memset+0x4>

08001df4 <_init>:
 8001df4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001df6:	bf00      	nop
 8001df8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001dfa:	bc08      	pop	{r3}
 8001dfc:	469e      	mov	lr, r3
 8001dfe:	4770      	bx	lr

08001e00 <_fini>:
 8001e00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001e02:	bf00      	nop
 8001e04:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001e06:	bc08      	pop	{r3}
 8001e08:	469e      	mov	lr, r3
 8001e0a:	4770      	bx	lr
